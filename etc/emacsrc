;; -*- mode: lisp-interaction; fill-column: 80 -*-
;; Emacs init file, 1992-2013, and onwards
;; Author: Martin Blais <blais@furius.ca>
;;
;; Debugging		: (setq debug-on-error t)
;; Shadowing problems	: emacs -batch -l ~/.emacs -f list-load-path-shadows
;; Updating versions	: M-x customize-changed-options
;; Document structure	: (occur "^;;;; \\* ")
;; Network boot		: (eval-buffer (browse-url-emacs "http://url/dot-emacs"))
;; Windows redirect	: (load "/path/to/etc/emacsrc")
;; Find available key   : (get-available-keybindings)
;;
;; REQUIREMENTS:
;; - Works with latest version (24), and previous version (23)
;; - Works without any locally installed packages
;; - Does not contain any user identification (to share others without side-effects)

;; Console vs. Graphics - emacsrc (two parts)
;; Non-standard modules - emacsrc.extra
;; Email setup - emacsrc.email
;; Projects - */etc/emacsrc, load them at the end only
;; TODO: refresh modules, mark as: distros which package it, whether I use it or not
;; TODO: use section names from the documentation
;; TODO: change a bunch of requires to autoloads, will start a lot faster! and won't fail without presence
;; TODO: remove all personal identification from this file (esp. email section) -> conf-home
;; TODO: clean up new overrides

(defvar home (getenv "HOME"))

;; Adjust default startup directory on platforms without a HOME.
(when (eq window-system 'w32)
  (setq default-directory "C:/Documents and Settings/mblais"))


;;------------------------------------------------------------------------------
;; User variables

(defvar user-projects-root (getenv "PROJECTS")
  "Directory where all personal projects are checked out.")


;;------------------------------------------------------------------------------
;; Lisp additions/corrections

;; When emacs is invoked with --debug-init, we want logging not to be truncated.
(when (or init-file-debug debug-on-error)
  (setq message-log-max t) )

;; Define an insert-or-create function for association lists, surprisingly
;; missing from Emacs...
(if (or (and (= emacs-major-version 24) (>= emacs-minor-version 4))
        (>= emacs-major-version 25))
    (defun aput (alist-sym key val)
      (let ((cons (assoc key (symbol-value alist-sym))))
        (if cons (setcdr cons val) (push (cons key val) (symbol-value alist-sym)))))
  (require 'assoc) ;; Deprecated.
  )

;; Filter function.
;; Note: you could replace this by cl/remove-if in 24.2
(when (not (fboundp 'filter))
  (defun filter (pred list)
    "Returns a list of all the elements fulfilling the pred requirement (that
       is for which (pred elem) is true)"
    (let (tmplist)
      (dolist (x list)
	(when (funcall pred x)
	  (push x tmplist)))
      (nreverse tmplist)))
  )


;;------------------------------------------------------------------------------
;; Setup load-path.

(defvar ignore-dirs '("CVS" ".svn" ".git" ".hg" ".bzr" ".mtn" "old")
  "Directories to ignore.")

(defun get-immediate-subdirs (root)
  "Return the current directory and its immediate subdirectories,
if they exist."
  (filter (lambda (x)
	    (and (file-directory-p x)
		 (not (member (file-name-nondirectory x) ignore-dirs))
		 ))
	  (cons root
		(directory-files root 'fullname "[^.]$" 'nosort))))


(setq load-path
      (append

       ;; Local checkouts of bleeding edge packages.
       (file-expand-wildcards (concat home "/src/elisp/*"))

       ;; All lib/elisp subdirectories from my projects, including conf.
       (when (and user-projects-root (file-exists-p user-projects-root))
	 (apply 'append (mapcar 'get-immediate-subdirs
				(file-expand-wildcards (concat user-projects-root "/*/lib/elisp")))))

       ;; Original load-path.
       load-path

       ;; /usr/share, in case we've installed our own Emacs under /usr/local and
       ;; we want packages installed by the distro.
       (when (file-exists-p "/usr/share/emacs/site-lisp")
	 (get-immediate-subdirs "/usr/share/emacs/site-lisp"))
       ))

(defun add-first-found-to-load-path (&rest paths)
  "Add the first path found to the load-path.
THis is convenient to use if you have optional git clones checked
out somewhere, or multiple locations some package root can be
found in."
  (let ((ini-file
         (car (filter #'file-exists-p paths))))
    (when ini-file
      (add-to-list 'load-path ini-file))))





;;------------------------------------------------------------------------------
;; ELPA

;; ;; For installation, download package.el from: http://tromey.com/elpa/package.el

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; Comment/uncomment this line to enable MELPA Stable if desired.  See `package-archive-priorities`
;; and `package-pinned-packages`. Most users will not need or want to do this.
;;(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(package-initialize)



;;;; ==========================================================================
;;;; *
;;;; *  Key bindings
;;;; *
;;;; ==========================================================================

;;------------------------------------------------------------------------------
;; Warn when overriding default bindings (we want to avoid doing that as much as
;; possible).

(defvar spit-out-override-warnings nil
  "Set this to true to print out override warnings.")

(defun warn-on-key-override (keymap bin fun)
  "Warns if a key has already been set and warns about the new binding."
  (when spit-out-override-warnings
    (let ((ffun (lookup-key keymap bin)))
      (if ffun
          (if fun
              (message "Warning: Overriding binding %s with %s (was mapped to %s)." bin fun ffun)
            (message "Warning: Removing binding %s (was mapped to %s)." bin ffun))))))

;; (defalias 'define-key* 'define-key)
;; (defalias 'global-set-key* 'global-set-key)
;; (defalias 'local-set-key* 'local-set-key)
;; (defadvice define-key (before warn-define-key-override activate)
;;   (apply 'warn-on-key-override (ad-get-args 0)))
;; (defadvice global-set-key (before warn-define-key-override activate)
;;   (apply 'warn-on-key-override (current-global-map) (ad-get-args 0)))
;; (defadvice local-set-key (before warn-define-key-override activate)
;;   (apply 'warn-on-key-override (current-local-map) (ad-get-args 0)))

;; IMPORTANT: These are not defined as advices, specifically because we don't
;; want overriding redefines in third-party package to spit out a warning. We
;; only really want to know about overriding redefines in our own code.

(defun define-key* (&rest args)
  (apply 'warn-on-key-override args)
  (apply 'define-key args))

(defun global-set-key* (&rest args)
  (apply 'warn-on-key-override (cons (current-global-map) args))
  (apply 'global-set-key args))

(defun local-set-key* (&rest args)
  (apply 'warn-on-key-override (cons (current-local-map) args))
  (apply 'local-set-key args))



;; TODO: check for control and meta keys too.
(defun get-available-keybindings (keymap)
  "Prints the free keys in the given keymap."
  (let ((c (1- ?a))
        avail)
    (while (and c (<= (incf c) ?z))
      (unless (lookup-key keymap `[(,c)])
        (add-to-list 'avail c)))
    avail))

;; C-x c
;; C-x j
;; C-x p
;; C-x x
;; C-x y



;;------------------------------------------------------------------------------
;; Restore as much sanity as possible under Mac OS X (installing Linux is really
;; the only way, but for those brief moments when you have to boot under Mac OS
;; X, this gives me a little less unhappiness). This is assuming Aquamacs.

(setq

 ;; If this is a Mac, whether I have the command and option keys switched around
 ;; or not, I want the key at the bottom left next to the spacebar to be the
 ;; meta key.
 mac-option-modifier 'meta
 mac-command-modifier 'alt

 ;; Make M-h be processed by Emacs instead of the system.
 mac-pass-command-to-system nil
 mac-pass-control-to-system nil

 ;; Open buffer in frames normally.
 one-buffer-one-frame nil

 )

;; Enable selection.
(setq x-select-enable-clipboard t)


;; I don't use Aquamacs anymore.
;; ;; Remove aquamacs bindings (if this is aquamacs).
;; (dolist (sym '(find-file
;;                forward-char
;;                backward-char
;;                save-buffers-kill-emacs))
;;   (let ((aquasym (intern (format "aquamacs-%s" (symbol-name sym)))))
;;     (substitute-key-definition
;;      (intern (format "aquamacs-%s" (symbol-name sym)))
;;      (intern (symbol-name sym))
;;      (current-global-map))))




;;------------------------------------------------------------------------------
;; Permanent additions
;;
;; Free keys: M-s C-M-m C-M-z  most of the C-S-<digit> keys,
;; C-x y,  C-x C-h, C-x C-j, C-x C-y, most of the C-c ... space
;;

;; Make control-h Backspace, and move help to C-\. {04d0116336e7}
(global-set-key (kbd "C-\\") 'help-command)
(global-set-key (kbd "C-h") 'delete-backward-char)


;; Use the default binding now: M-g M-g
;;(global-set-key* [(meta g)] 'goto-line)

(global-set-key* [(meta o)] 'overwrite-mode)
(global-set-key* [(meta S)] 'center-paragraph)


;;(global-set-key* [(control J)] 'delete-indentation)
;; is already bound to M-^

;; Bind a function to join the FOLLOWING lines, like in 'vi'.
(define-key* ctl-x-map [(control j)] (lambda () (interactive) (delete-indentation t)))

;;;(global-set-key* [(control =)] 'call-last-kbd-macro)
;; you can achieve the same effect with C-x e C-x z z z z z z z
;; it would be nice to have C-x e e e e e, but looking at repeat.el, that seems
;; non- trivial to implement.

(global-set-key* [(meta backspace)] 'backward-kill-word)

(global-set-key* [(meta shift backspace)] 'backward-kill-capword)
(global-set-key* [(control backspace)] 'backward-kill-capword)

;; For terminals.
(global-set-key* [(?\M-\d)] 'backward-kill-word)
(global-set-key* [(?\e) (?\M-\d)] 'backward-kill-capword)


;; experimental override of the default.
;;(global-set-key* [(meta backspace)] 'backward-kill-capword)

;; On the mac, we like to be able to use Super-BackSpace as well as M-BackSpace.
;;; FIXME: how do we capture the Option key?
;;; (global-set-key* [(option backspace)] 'backward-kill-capword)


;; Disable the Return key so that we can get used to using C-m instead.
;; (defmacro require-repeat (fun)
;;   "Run the given command only if the last character was the same
;; as the current one."

;; (global-set-key* [(return)] 'newline)

;; Remove annoying iconification binding.
(global-set-key* [(control z)] nil)



;; Move the toggle-input-method bindings that I'm tripping over all the time!
;;(global-set-key* [(control \\)] nil) ;; Removed b/c {04d0116336e7}
(define-key* ctl-x-map [(\\)] 'toggle-input-method)



;;;; ==========================================================================
;;;; *
;;;; *  Standard Settings and Packages
;;;; *
;;;; ==========================================================================

;; Ring the bell in the console (FIXME: this does not appear to work).
;; (setq visible-bell nil)
;; (setq ring-bell-function nil)
;; (ding)


;;------------------------------------------------------------------------------
;; Remove bindings which aren't accessible from a real console.

;; This only helps in a graphical emacs; it actually does nothing in an X
;; terminal: C-/ is received as C-_ under an X terminal. In the real console,
;; C-/ renders as DEL, so it's not helpful. Just unlearn to use it.
(global-set-key* [(control slash)] nil)

;; Remove C-<number> bindings.
(dolist (num '(1 2 3 4 5 6 7 8 9 0))
  (global-set-key* [(control num)] nil))

;; Convenient binding for q-r-r
(defalias 'qrr 'query-replace-regexp)

;; A query replace function that replaces the active region.
(defun query-replace-active-region (beg end to-string)
  (interactive "r\nsQuery replace: ")
  (let ((from-string (buffer-substring beg end)))
    (goto-char (region-beginning))
    (deactivate-mark)
    (query-replace from-string to-string)
    ))

(defalias 'qra 'query-replace-active-region)


;;------------------------------------------------------------------------------
;; Repeatable commands.

(require 'repeatable nil t)

(when (featurep 'repeatable)
  (repeatable-command-advice call-last-kbd-macro)
  (repeatable-command-advice enlarge-window)
  (repeatable-command-advice shrink-window)
  (repeatable-command-advice enlarge-window-horizontally)
  (repeatable-command-advice shrink-window-horizontally)
  )


;;------------------------------------------------------------------------------
;; Fix indent-rigidly for Emacs 24.4 fuckedupedness, I don't have arrow keys on
;; my keyboard!

(if (or (and (= emacs-major-version 24) (>= emacs-minor-version 4))
        (>= emacs-major-version 25))
    (progn
      (define-key* indent-rigidly-map [?>] 'indent-rigidly-right)
      (define-key* indent-rigidly-map [?<] 'indent-rigidly-left) )
  (repeatable-command-advice indent-rigidly))


;;------------------------------------------------------------------------------
;; Backspace chars and terminals.

;; Note: if you have trouble in terminals, maybe setting this to nil will help.
;; (custom-set-variables '(normal-erase-is-backspace nil))


;;------------------------------------------------------------------------------
;; Undisabled commands.

(put 'narrow-to-page 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'eval-expression 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)

;; Remap narrow-to-region because C-x n n gets overloaded.
(define-key* ctl-x-map [(n)(r)] 'narrow-to-region)

;; Switch over the prefix of the set-goal-column command, so that the default is
;; to reset it, and the prefixed command to set it.
(defun set-goal-column-inverted ()
  (interactive)
  (let ((current-prefix-arg (not current-prefix-arg)))
    (call-interactively 'set-goal-column)))

(put 'set-goal-column 'disabled nil)
(substitute-key-definition
 'set-goal-column 'set-goal-column-inverted
 (current-global-map))



;;------------------------------------------------------------------------------
;; Basic editing settings.

;; Highlights the selected text.
(setq transient-mark-mode t
      delete-active-region nil
      highlight-nonselected-windows t
      mark-even-if-inactive t)

;; Switches between killing the ending newline or not on kill-line.
(setq kill-whole-line t)

;; Pending delete-mode deletes selected region on input.
;; (setq delete-selection-mode nil)

;; Garbage collector size (500K for allocating stuff).
(setq gc-cons-threshold 500000)

;;(setq comment-column 56)

;; Scratch buffer should be clean.  I've read that message a zillion times.
;; Also remove all the startup screens and other BS.
(setq initial-scratch-message nil
      inhibit-startup-echo-area-message t
      inhibit-startup-screen t)


;;------------------------------------------------------------------------------
;; Settings affecting end of buffer

;; Don't expand files when scrolling past the end.
(setq next-line-add-newlines nil)

;; What to do with files that don't have a final newline.
(setq require-final-newline 'ask)

;; Indicate end of buffer like vi's tildes.
(setq-default indicate-empty-lines t)


;;------------------------------------------------------------------------------
;; Change all annoying yes or no prompts to the more convenient y/n prompts.

(fset 'yes-or-no-p (symbol-function 'y-or-n-p))


;;------------------------------------------------------------------------------
;; I often need to delete-whitespace and indent

(defun delete-horizontal-space-and-indent ()
  (interactive)
  (delete-horizontal-space)
  (indent-for-tab-command))

(define-key* global-map [(shift control i)] 'delete-horizontal-space-and-indent)


;;------------------------------------------------------------------------------
;; Cursor

(if (fboundp 'blink-cursor-mode)
    (progn
      (blink-cursor-mode t)
      (setq blink-cursor-interval 0.5)
      (setq blink-cursor-delay 10)
      ))

;; (blink-cursor-mode nil)
;; Note: we should avoid flashing the cursor when in remote mode.

;; Stretch cursor for tabs... highly annoying!
;; (setq x-stretch-cursor t)


;;------------------------------------------------------------------------------
;; text-mode and filling settings.

(setq-default indent-tabs-mode nil)
(setq indent-tabs-mode nil)

(setq sentence-end-double-space nil)   ; One SPC ends a sentence
;;(setq adaptive-fill-mode t)    ; fill par. on second line of par.
;;(setq default-justification 'left)


;;*** If the variable colon-double-space is non-nil, the explicit fill
;;commands put two spaces after a colon.
(setq colon-double-space t)

(setq default-fill-column 80)
(setq-default fill-column 80)
(setq-default resize-column 80)

;; For the console, override abbrev-prefix-mark, which we never use.
(global-set-key* [(meta \')] 'fill-region)


(defun user-text-mode-hook ()
  (auto-fill-mode t)
  ;; (refill-mode t) ;; This does not work well with itemized lists.
  )

(add-hook 'text-mode-hook 'user-text-mode-hook)

(add-to-list 'auto-mode-alist '("\\(CHANGES\\|TODO\\|README\\)" . text-mode))
(add-to-list 'auto-mode-alist '("\\.desc" . text-mode))



;;------------------------------------------------------------------------------
;; Local variables.

(setq enable-local-variables 't)        ; [don't] ask me for local variables
;;(setq enable-local-eval 'ask)


;;------------------------------------------------------------------------------
;; Backup files.

(setq make-backup-files nil)            ; don't make xxx~ files

;; Make all backup files in the user's backup directory.
;;; (setq backup-directory-alist (list (cons "." "/.emacs-backup")))


;; Can also use VERSION_CONTROL
;;(setq version-control t)

;;(setq kept-old-versions)
;;(setq kept-new-versions)
;;(setq delete-old-versions)

;;(setq vc-make-backup-files

;; Directories where no backups occur.
;;(setq temporary-file-directory, small-temporary-file-directory)

;; ** New user options `backup-directory-alist' and
;; `make-backup-file-name-function' control the placement of backups,
;; typically in a single directory or in an invisible sub-directory.


;;------------------------------------------------------------------------------
;; Shadowing files.

;; none for now.


;;------------------------------------------------------------------------------
;; Displayed stuff.

;; Remove menu-bar and tool-bar.
(menu-bar-mode 0) ;; FIXME: Not sure if this'll work in 23
(when (fboundp 'tool-bar-mode)
  (unless (eq system-type 'darwin)
    (tool-bar-mode nil)))

;; Display column number.
(setq column-number-mode 't)


;;------------------------------------------------------------------------------
;; International characters.

;; Semi-obsolete.
;; (standard-display-european +1)

(setq-default default-enable-multibyte-characters t)


;; Mule.
(setq default-input-method "latin-postfix")


;;------------------------------------------------------------------------------
;; Language environment

(set-coding-system-priority coding-category-utf-8)


;;     (defun my-chinese-setup ()
;;       "Set up my private Chinese environment."
;;       (if (equal current-language-environment "Chinese-GB")
;;           ))
;;     (add-hook 'set-language-environment-hook 'my-chinese-setup)
;;

;; (set-language-environment "ASCII")
;; (set-language-environment "Japanese")
;; (setup-latin1-environment)

;;(require 'iso-syntax);; iso stuff for converting accents in frame
;;(require 'iso-cvt)

;; coding systems
;; (setq default-buffer-file-coding-system 'iso-latin-1-unix)

;; Internationalization and localization support (i18n, l10n)

;;(add-to-list 'auto-mode-alist '("\\.po[tx]?\\'\\|\\.po\\." . po-mode))
;;(require 'po-mode)

;;(autoload 'po-find-file-coding-system "po-mode")
;;(modify-coding-system-alist 'file "\\.po[tx]?\\'\\|\\.po\\."
;;                            'po-find-file-coding-system)





;;------------------------------------------------------------------------------
;; dired mode.

;; Extended stuff.
(require 'dired-x)
(require 'rx)

(setq dired-recursive-deletes 'always
      dired-listing-switches "-al" ;; "-aoh"
      dired-omit-size-limit 100000
      dired-omit-extensions nil
      dired-omit-files (rx (or
			    (seq bol (or "." "..")) ; directories
			    (seq bol (? ".") "#") ; emacs autosave files
			    (seq "~" eol) ; backup-files
			    (seq bol ".svn" eol) ; svn dirs FIXME use ignore-dirs, or is this not default now?
			    (seq ".pyc" eol) ; python compiled file
			    ))
      )
(setq-default dired-omit-files-p t)

;; Replace xpdf by evince.
(require 'cl-lib)
(setq dired-guess-shell-alist-default
      (cl-subst "evince" "xpdf" dired-guess-shell-alist-default
                :test (lambda (old new) (and (stringp new) (string= old new)))))

;(setq find-file-run-dired nil)
;(require 'find-dired), now a default.


;;------------------------------------------------------------------------------
;; change-log

;; customizations related to add-log.el

(setq add-log-keep-changes-together t)
(setq add-log-current-defun-function nil);;(lambda () nil))
(setq add-log-file-name-function nil);;(lambda(x) nil))
;;(defcustom add-log-current-defun-header-regexp

(setq add-log-mailing-address user-login-name)


;;------------------------------------------------------------------------------
;; Vertical scrolling and moving

;; Settings.
(setq next-screen-context-lines 10)
(setq scroll-margin 0)
(setq scroll-step 1)
(setq scroll-preserve-screen-position t)
(setq scroll-conservatively 1000)

;; In my normalized bindings, the following concepts prevail. Generally:
;;
;;  keys        concept     control          meta(alt)      ctrl+meta(alt)
;;  ==========  ----------  ---------------  -------------  ---------------
;;  f/b         (horiz)     characters       words          sexp
;;  d/Backspace (delete)    del chars        del words      del sexp (*)
;;  n/p         (vert)      lines            paragraphs     list
;;  a/e         (beg/end)   (beg/end)line    sentence       functions (mode)
;;
;; Orthogonal to this is the notion that the shift key makes the vertical
;; movement scroll rather that move the cursor.  The cursors stays in the same
;; place.
;;
;; These bindings have been carefully chosen with respect to the
;; defaut emacs bindings for moving around.


;; Function that scrolls but that keeps the cursor in the same place in the
;; window.
(defun scroll-up-still (&optional n)
  "Scroll some lines but move the cursor the same amount of lines the opposite
way"
  (let ((nn (or n 1)))
    (scroll-up nn)
    (forward-line nn)) )

;; Scroll one line down and keep the cursor at its same relative pos.
(defun scroll-up-short (&optional n)
  (interactive)
  (let ((n (or n 1)))
    (scroll-up-still n)))

(defun scroll-down-short (&optional n)
  (interactive)
  (let ((n (or n 1)))
    (scroll-up-still (- n))))

(global-set-key* [(control N)] 'scroll-up-short)
(global-set-key* [(control P)] 'scroll-down-short)


;;
;; Paragraph movements.
;;
(defvar user-paragraphs-movement-style 'dubious
  "Style for the paragraphs movement.")

(cond
 ((eq user-paragraphs-movement-style 'dubious)
  (global-set-key* [(meta n)] 'dubious-forward-paragraph)
  (global-set-key* [(meta N)] 'dubious-forward-paragraph-scroll)
  (global-set-key* [(meta p)] 'dubious-backward-paragraph)
  (global-set-key* [(meta P)] 'dubious-backward-paragraph-scroll)
  )

 ((eq user-paragraphs-movement-style 'some)
  (global-set-key* [(meta p)] 'user-previous-some-lines)
  (global-set-key* [(meta n)] 'user-next-some-lines)
  (global-set-key* [(meta N)] 'user-scroll-some-up)
  (global-set-key* [(meta P)] 'user-scroll-some-down)
  )

 ((eq user-paragraphs-movement-style 'paragraphs)
  (defun forward-paragraph-lines (&optional n)
    (save-excursion
      (let ((bp (point))
            (nn (or n 1))
            cl)
        (forward-paragraph nn)
        (setq cl (count-lines bp (point)))
        (if (>= nn 0) cl (- cl))
        )))
  (defun forward-paragraph-scroll (&optional n)
    (interactive)
    (scroll-up-still (forward-paragraph-lines n)))
  (defun backward-paragraph-scroll (&optional n)
    (interactive)
    (scroll-up-still (- (forward-paragraph-lines (- (or n 1))))))
  (global-set-key* [(meta p)] 'backward-paragraph)
  (global-set-key* [(meta n)] 'forward-paragraph)
  (global-set-key* [(meta N)] 'forward-paragraph-scroll)
  (global-set-key* [(meta P)] 'backward-paragraph-scroll)
  ))



;; A more useful recenter.
(defun recenter-top ()
  "Recenter current line near the top of window."
  (interactive)
  (recenter 5))

(defadvice recenter (after user-recenter-refontify activate)
 "If recenter is invoked just with \\[universal-argument],
re-fontify the buffer (if font-lock is enabled)."
 (when (and (equal current-prefix-arg '(4))
            font-lock-mode)
   (font-lock-ensure)))

(global-set-key* [(control L)] 'recenter-top)



;; In addition, I add a set of bindings for scrolling "some" lines.  These are
;; bound to the [, ] keys.  The shift modifier for scrolling is also supported.
;;
;; Note: watch the top and bottom edge cases.  Scrolling has to happen before
;; moving.

(defvar user-some-lines 4
  "Number of lines to scroll or move the cursor when using the user-scroll
functions.")

;; Move cursor vertically down/up some lines.
(defun user-next-some-lines ()
  (interactive) (forward-line user-some-lines))
(defun user-previous-some-lines ()
  (interactive) (forward-line (- user-some-lines)))

(defun user-scroll-some-up (&optional n)
  (interactive)
  (let ((nn (or n user-some-lines)))
    (scroll-up nn)
    (forward-line nn) ))

(defun user-scroll-some-down ()
  (interactive) (user-scroll-some-up (- user-some-lines)))


;; Stuff the paragraph movements I set above. Sorry, too much pain to change.
;; (if t
;;     (progn
;;       (global-set-key* [(meta p)] 'user-previous-some-lines)
;;       (global-set-key* [(meta n)] 'user-next-some-lines)
;;       (global-set-key* [(meta N)] 'user-scroll-some-up)
;;       (global-set-key* [(meta P)] 'user-scroll-some-down) ))

;; (global-set-key* [(meta ?\])] 'user-previous-some-lines)
;; (global-set-key* [(meta ?\[)] 'user-next-some-lines)
;; (global-set-key* [(meta ?{)] 'user-scroll-some-up) ;; overrides default paragraph
;; (global-set-key* [(meta ?})] 'user-scroll-some-down) ;; overrides default paragraph
;; (global-set-key* [(meta ?{)] 'backward-paragraph)
;; (global-set-key* [(meta ?})] 'forward-paragraph)


;; ** There is a new "aggressive" scrolling method; try it.

;;------------------------------------------------------------------------------
;; Local copy of dubious-paragraphs.el

(defun dubious-scroll-up-still (&optional n)
  "Scroll lines and move the cursor the same amount in the opposite direction.
This is not really dubious but used here so we define it privately.  N is the
number of lines to scroll."
  (let ((nn (or n 1)))
    (scroll-up nn)
    (if (not running-precisely-emacs-21)
	(forward-line nn)) ))

(defvar dubious-min 3
  "Minimum number of lines to travel for a dubious paragraph movement.")
(defvar dubious-max 8
  "Maximum number of lines to travel for a dubious paragraph movement.")
(defvar dubious-dubious 5
  "Number of lines to travel if paragraph movement is dubious.")

(defun dubious-forward-paragraph-lines (&optional n)
  "Compute the number of lines for dubious paragraph movement of N paragraphs."
  (let* ((ninit (or n 1))
	 (bp (point))
	 nl )
    ;; Count the number of lines required to move by paragraphs beyond
    ;; that needed to satisfy the minimum lines requirement.
    (setq nl
	  (save-excursion
	    (let ((inc (if (>= ninit 0) 1 -1))
		  ;; If we're moving up, we want to not move to the line before
		  ;; the paragraph, because we want to be on the first line of
		  ;; the paragraph when we're moving up (it makes it easier to
		  ;; select meaningful chunks).
		  (offset (if (>= ninit 0) 0 1)) ;;; moving up only
		  ;; previous point, to avoid infinite loop at buffer boundaries
		  ppoint (point))
	      ;; First move the requested number of paragraphs

              (let ((max-lines (* 2 dubious-max)))
                (narrow-to-region
                 (save-excursion (forward-line (- max-lines)) (point))
                 (save-excursion (forward-line max-lines) (point))) )
              (forward-paragraph ninit)
              (widen)

	      ;; Then move one more paragraph in the same direction until
	      ;; the number of lines is greater than the minimum.
	      (while (and (< (- (count-lines bp (point)) offset)
			     dubious-min)
			  (not (equal ppoint (point))))
		(setq ppoint (point))
		(forward-paragraph inc) )
	      ;; and return that number of lines
	      (if (equal (point) (point-min))
		  (setq offset 0))
	      (- (count-lines bp (point)) offset)
	      )))

    ;; Here, we've got the number of lines moved by paragraphs to get
    ;; beyond the minimum.

    ;; If the number of lines is beyond the maximum as well.
    (if (> nl dubious-max)
	;; Set if to the dubious fixed value.
	(setq nl dubious-dubious))

    ;; Return an appropriately signed value.
    (if (>= ninit 0) nl (- nl))
    ))

(defun dubious-forward-paragraph (&optional n)
  "Move forward to end of N paragraphs, if within a set range of lines.
Otherwise move a fixed number of lines."
  (interactive)
  (forward-line (dubious-forward-paragraph-lines n)))

(defun dubious-backward-paragraph (&optional n)
  "Move backward to end of N paragraphs, if within a set range of lines.
Otherwise move a fixed number of lines."
  (interactive)
  (forward-line
   (dubious-forward-paragraph-lines (- (or n 1)))))

(defun dubious-forward-paragraph-scroll (&optional n)
  "Scroll forward to end of N paragraphs, if within a set range of lines.
Otherwise scroll a fixed number of lines."
  (interactive)
  (scroll-up-still
   (dubious-forward-paragraph-lines n)))

(defun dubious-backward-paragraph-scroll (&optional n)
  "Scroll backward to end of N paragraphs, if within a set range of lines.
Otherwise scroll a fixed number of lines."
  (interactive)
  (scroll-up-still
   (dubious-forward-paragraph-lines (- (or n 1)))))



;;------------------------------------------------------------------------------
;; Settings that make handling long lines faster.
;; https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html

(setq-default bidi-paragraph-direction 'left-to-right)
(if (version<= "27.1" emacs-version)
    (setq bidi-inhibit-bpa t))

;; If you're working with a file with very long lines, but the major mode is not
;; that important (for example minified JavaScript, XML, JSON or log files),
;; then you can use so-long mode


;;------------------------------------------------------------------------------
;; Horizontal scrolling

;; -> (require 'scroll-in-place) ;; new hscrolling commands
;; -> (setq scroll-in-place nil)
;;(setq-default auto-show-mode 't) ;; needs to be run as of 20.4

;; FIXME: need to re-enable these for versions <=22
;;
;; (require 'auto-show)    ;; enable auto scrolling at the end of long lines
;;
;; (add-hook 'c-mode-common-hook '(lambda() (auto-show-mode t)) t t)
;; (add-hook 'compilation-mode-hook '(lambda() (auto-show-mode t)) t t)
;;
;; ;; These are nice additions, since the true bindings (C-x >) are so awkward.
;; (global-set-key* [(control <)] 'scroll-right)
;; (global-set-key* [(control >)] 'scroll-left)


;;------------------------------------------------------------------------------
;; TAB key

;; Note: the switch-to-other-buffer function already exists in Xemacs.
(defun switch-to-other-buffer ()
  "Applies switch-to-buffer (other-buffer) interactively."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 't)))

(global-set-key* [(control tab)] 'switch-to-other-buffer) ; Only works in console
(global-set-key* [(meta i)] 'switch-to-other-buffer) ; for consoles, overrides default tab-to-tab-stop

;; Note: this is now used for the company-specific binding.
;;;(global-set-key* [(control z)] 'switch-to-other-buffer) ; Override C-z suspend-emacs for consoles

;;; New function to force a tab more easily.
(defun tab-anyway ()
  "Inserts a tab, unconditionally.
With prefix arg, inserts spaces until the first non-whitespace character
on the previous line, starting from the current horizontal position."
  (interactive)
  (if (equal current-prefix-arg nil)
      (insert-char 9 1)
    (let ((col (current-column))
          (ncol nil))
      (save-excursion
        (forward-line -1)
        (move-to-column col)
        (if (= col (current-column))
            (progn
              (skip-chars-forward " \t")
              (setq ncol (current-column)))))
      (insert-char ?\  (- ncol col))
      )
    ))

(global-set-key* [(shift iso-lefttab)] 'tab-anyway)


;;------------------------------------------------------------------------------
;; zap changes.

;; This is a portion of the original zap-to-char that I reuse in its
;; redefinition, and in a few functions.
(defun compute-zap-position (arg char &optional alt)
  (save-excursion
    (if (char-table-p translation-table-for-input)
	(setq char (or (aref translation-table-for-input char) char)))
    (let* ((case-fold-search nil) ;; make case sensitive.
	   (begin (point))
	   (origchar (string-to-char
		      (if (> arg 0)
			  (buffer-substring (point) (1+ (point)))
			(buffer-substring (1- (point)) (point)))))
	   (end (progn
		  (when (and alt (= origchar char))
		    (goto-char (if (> arg 0) (1+ (point)) (1- (point)))))
		  (search-forward (char-to-string char) nil nil arg)
		  (when (or alt (not (= origchar char)))
		    (goto-char (if (> arg 0) (1- (point)) (1+ (point)))))
		  (point)))
	   )
      (list begin end)
      )))

;; It is better redefined this way rather than to implement this with an advice,
;; because the kill-region would have to be adjusted otherwise, which is
;; unclean.
(defun zap-up-to-char (arg char)
  "A version of zap-to-char that does not include the char we're searching for.
This version ignores the char if it is right next to the cursor when
the function is invoked."
  (interactive "p\ncZap up to char: ")
  (when (looking-at (char-to-string char))
    (delete-char 1))
  (let ((begend (compute-zap-position arg char)))
    (apply 'kill-region begend)
    ))

(defalias 'zap-to-char 'zap-up-to-char)

;; FIXME: This would be awesome, but happens not to work right now.
;; TODO: Look into it.
;;(repeatable-command-advice zap-to-char)


(defun move-to-char (arg char)
  "Like zap-to-char but don't remove the contents."
  (interactive "p\ncMove forward to char: ")
  (let ((begend (compute-zap-position arg char t)))
    (goto-char (cadr begend))))

(defun move-to-char-reverse (arg char)
  (interactive "p\ncMove backward to char: ")
  (move-to-char (- arg) char)
  ;(backward-char (if (< arg 0) -1 +1))
  )


;; Note: bindings for these have now been mapped in 24; we need new bindings to
;; replace them.
;;(global-set-key* [(meta s)] 'move-to-char)
;;(global-set-key* [(meta r)] 'move-to-char-reverse)

(when (featurep 'repeatable)
  (repeatable-command-advice move-to-char)
  (repeatable-command-advice move-to-char-reverse) )


(defun copy-to-char (arg char)
  "Like zap-to-char but copy the contents without moving the cursor."
  (interactive "p\ncCopy up to char: ")
  (let ((begend (compute-zap-position arg char t)))
    (apply 'kill-ring-save begend)
    ))

;(global-set-key* [(meta S)] 'copy-to-char)



;; ;; Make zap-to-char not include the character by default.
;; (defadvice zap-to-char (after zap-up-to-char-advice (arg char) activate)
;;   "Kill up to the ARG'th occurence of CHAR, and leave CHAR.
;; The CHAR is replaced and the point is put before CHAR."
;;   (insert char)
;;   (forward-char (if (> arg 0) -1 0)))
;;
;; (defadvice zap-to-char (around zap-case-insensitive-advice (arg char) activate)
;;   "Make zap-to-char case sensitive."
;;   (let ((case-fold-search nil))
;;     ad-do-it))


;;------------------------------------------------------------------------------
;; isearch customizations.

;; Often during incremental search I want to delete the search match.  This
;; binds the C-k key in isearch mode to to just that.
(defun kill-isearch-match ()
  "Kill the current isearch match string and continue searching."
  (interactive)
  (kill-region isearch-other-end (point)))

(define-key* isearch-mode-map [(control k)] 'kill-isearch-match)



(defun isearch-yank-sexp ()
  "A version of isearch-yank-word-of-char that uses sexps."
  (interactive)
  (isearch-yank-internal
   (lambda ()
     (forward-sexp 1) (point))))

(define-key* isearch-mode-map [(control meta w)] 'isearch-yank-sexp)



(defun zap-to-isearch (rbeg rend)
  "Kill the region between the mark and the closest portion of
the isearch match string. The behaviour is meant to be analogous
to zap-to-char; let's call it zap-to-isearch. The deleted region
does not include the isearch word. This is meant to be bound only
in isearch mode.

The point of this function is that oftentimes you want to delete
some portion of text, one end of which happens to be an active
isearch word. The observation to make is that if you use isearch
a lot to move the cursor around (as you should, it is much more
efficient than using the arrows), it happens a lot that you could
just delete the active region between the mark and the point, not
include the isearch word."
  (interactive "r")
  (let* ((barrier (if mark-active (mark) isearch-barrier))
         (isearch-bounds (list isearch-other-end (point)))
         (ismin (apply 'min isearch-bounds))
         (ismax (apply 'max isearch-bounds))
         )
    (if (< barrier ismin)
        (progn (kill-region barrier ismin)
               (goto-char barrier))
      (if (> barrier ismax)
          (progn (kill-region ismax barrier)
                 (goto-char ismax))
        (error "Internal error in isearch kill function.")))
    (isearch-exit)
    ))

(define-key* isearch-mode-map [(meta z)] 'zap-to-isearch)


(defun isearch-exit-other-end (rbeg rend)
  "Exit isearch, but at the other end of the search string.
This is useful when followed by an immediate kill."
  (interactive "r")
  (isearch-exit)
  (goto-char isearch-other-end))

;; Note: This doesn't appear to work in the console. C-RET is not a thing.
(define-key* isearch-mode-map [(control return)] 'isearch-exit-other-end)



;;------------------------------------------------------------------------------
;; Shell.

(if (not (eq system-type 'windows-nt))

    ;; Default shell under unix.
    (setq shell-file-name "/bin/bash")

  ;; Generic config for Windows at home (never tested).
  (let* ((cygwin-root "C:/Cygwin")
         (cygwin-bin (concat cygwin-root "/bin")))
    (setenv "HOME" (concat cygwin-root "/home/blais"))
    (setenv "PATH" (concat cygwin-bin ";" (getenv "PATH")))
    (setq exec-path (cons cygwin-bin exec-path))
    (setq shell-file-name "bash")
    (setq explicit-shell-file-name "bash"))
  )


(require 'shell)
(defadvice shell (around shell-cd-init-buffer activate)
  "When creating a new shell, cd to the current buffer's directory
automatically."
  (let* ((initdir
          (if buffer-file-name
              (file-name-directory buffer-file-name) default-directory))
         (cmd (format "cd %s\n" initdir))
         (proc ad-do-it))
    (comint-send-string (get-buffer-process proc) cmd)) )


;;(setq shell-mode-hook nil)
(add-hook 'shell-mode-hook
          (lambda ()
	    ;; (setenv "PS1" [(control u)])
	    ;; (local-unset-key [(control l)])
	    ;; (local-unset-key [(control u)])
	    (ansi-color-for-comint-mode-on)
	    ))
;; Note: this doesn't work yet, but this is what I want.

;;------------------------------------------------------------------------------
;; Better copy function.

;; This binding replaces kill-ring-save with a version that copies the current
;; line that the cursor is on if the region is not active.
(defun kill-ring-save-region-or-line ()
  "Like kill-ring-save, but if the region is not active save until the end of
the current line. If the region is not active and there is a numerical
prefix-argument, copy that many lines from the current line. If the numerical
prefix argument is negative, copy that many lines before the current line."

  (interactive)
  (if mark-active
      (call-interactively 'kill-ring-save)
    (progn
      (if (not current-prefix-arg)
          (let ((bol (point))
                (eol (min (+ (line-end-position) 1) (point-max))))
            (progn
              (kill-ring-save bol eol)
              (princ "Copied current line.")))
        (let ((bol (point))
              (eol (save-excursion
                     (forward-line (prefix-numeric-value current-prefix-arg))
                     (min (line-beginning-position) (point-max)))))
          (progn
            (kill-ring-save bol eol)
            (princ "Copied many lines.")))
        ))))

(substitute-key-definition 'kill-ring-save 'kill-ring-save-region-or-line
                           (current-global-map))

;;------------------------------------------------------------------------------
;; A yank with replacement.

(defun yank-replace ()
  "Yank, replacing the currently active region."
  (interactive)
  (kill-region (point) (mark))
  (yank 2))

(global-set-key* [(control meta y)] 'yank-replace)


;;------------------------------------------------------------------------------
;; Yank the X clipboard (uses an external program: pcb).
;; This is useful in console mode, where there is on X accessible.

(defun clipboard-yank-external ()
  (interactive)
  (shell-command "pcb" t))

(global-set-key* [(control c)(control y)] 'clipboard-yank-external)


;;------------------------------------------------------------------------------
;; Line truncation.

(setq-default truncate-lines t)
;;(setq truncate-partial-width-windows nil) ; for line truncate


(if (not (fboundp 'toggle-truncate-lines))
    (defun toggle-truncate-lines ()
      (interactive)
      (setq truncate-lines (not truncate-lines))))

(define-key* ctl-x-map [(t)] 'toggle-truncate-lines)


;;------------------------------------------------------------------------------
;; Matching parenthesis highlight.

(show-paren-mode nil) ;; disabled
(setq show-paren-delay 0.5)
;; (setq show-paren-style 'parenthesis)
;; (setq show-paren-ring-bell-on-mismatch t)

(setq blink-matching-paren t)
(defun unbound-blink-matching-open ()
  "blink-matching-open that extends to the beginning-of-buffer if necessary."
  (interactive)
  (let ((blink-matching-paren-distance (buffer-size)))
    (blink-matching-open)))

;;(global-set-key* [(control \))] 'unbound-blink-matching-open)
;; Could also bind to (show-paren-function) but it's sticky and annoying.



;;------------------------------------------------------------------------------
;; Automatic insertion of matching parentheses.

(when nil
  ;;http://code.google.com/p/autopair/
  ;; This is too slow--it's slowing down input noticeably [2014-05-06 unbearable]
  (require 'autopair)
  (autopair-global-mode)

  (add-hook 'c++-mode-hook
	    (lambda () (push '(?< . ?>) (getf autopair-extra-pairs :code))))
  )


;; (setq skeleton-pair t)
;; (global-set-key "(" 'skeleton-pair-insert-maybe)
;; (global-set-key "[" 'skeleton-pair-insert-maybe)
;; (global-set-key "{" 'skeleton-pair-insert-maybe)
;; (global-set-key "'" 'skeleton-pair-insert-maybe)
;; (global-set-key "\"" 'skeleton-pair-insert-maybe)



(autoload 'paredit-mode "paredit"
  "Minor mode for pseudo-structurally editing Lisp code."
  t)

;;(smartparens-global-mode nil)
;; (when (require 'smartparens nil t)
;;   (smartparens-global-mode t)
;;   (setq sp-navigate-close-if-unbalanced t) )

(when (require 'close-matching nil t)
  (close-matching-install-bindings global-map))

;; (setq electric-pair-pairs '(
;;                             (?\" . ?\")
;;                             (?\{ . ?\})
;;                             ) )
;; (setq electric-pair-preserve-balance nil)
;; (electric-pair-mode -1)

;; (setq electric-pair-preserve-balance nil)
;;(setq electric-pair-inhibit-predicate electric-pair-conservative-inhibit)



;;------------------------------------------------------------------------------
;; auto-modes for many standard modes.

(setq auto-mode-alist
      (append '( ("\\.perl$" . perl-mode)
                 ("\\.h$"   . c++-mode) ;; override C-mode
                 ("\\.csh$" . csh-mode)
                 ("wmrc$" . winmgr-mode)
                 ("\\.qml$" . html-mode)
                 ("\\.ctwmrc$" . m4-mode) )
              auto-mode-alist))

;; Remove nroff-mode auto-mode on .digit files (e.g. file.1).
(setq auto-mode-alist
   (assq-delete-all "\\.[12345678]\\'"
   (assq-delete-all "\\.[1-9]\\'" auto-mode-alist)))


;;** The new variable `auto-mode-interpreter-regexp' contains a regular
;;expression matching interpreters, for file mode determination.



;;------------------------------------------------------------------------------
;; Dynamic abbrevs.

(setq dabbrev-case-fold-search nil)
;;(setq dabbrev-case-replace nil)

(defmacro make-abbrev-inserter (template &optional rp lp)
  `(lambda () (insert-with-replacement ,template ,rp ,lp)))

(defun insert-with-replacement (template &optional replace-pat* locate-pat*)
  (let* ((replace-pat (or replace-pat* "%"))
	 (locate-pat (or locate-pat* "%"))
	 (replacement (read-string "Insert: " ))
	 (template1 (replace-regexp-in-string replace-pat replacement template))
	 (start (string-match locate-pat template1))
	 (template2 (replace-regexp-in-string locate-pat "" template1))
	 (pt (point)))
    (insert template2)
    (when start
      (goto-char (+ pt start)))))

;;------------------------------------------------------------------------------
;; Hippie Expand

;; Replace dabbrev-expand by hippie-expand; rebind on M- + dabbrev binding.
(global-set-key* [(meta ??)] 'hippie-expand)
;;(global-set-key* [(meta /)] 'dabbrev-expand)
;; hippie-expand-verbose t
;; hippie-expand-try-functions-list


;;------------------------------------------------------------------------------
;; Convenient Insertions

;; FIXME: This should be converted to dynamic abbrevs, or at least to an assoc-list, no insert-* symbol BS allowed.

(require 'time-stamp) ;;FIXME do we still require this for emacs-21?

(defun insert-email ()
  (insert user-mail-address))

(defun insert-author ()
  (insert (format "%s <%s>" user-full-name user-mail-address)))

(defun insert-author-rev ()
  (insert (format "%s (%s)" user-mail-address user-full-name)))


(defun insert-date ()
  ;; ISO 8601 format
  (insert (time-stamp-string "%:y-%02m-%02d")))

(require 'calendar)
(defun insert-yesterday ()
  (interactive)
  (insert
   (let* ((today (calendar-current-date))
	  (yesterday (calendar-gregorian-from-absolute
		      (1- (calendar-absolute-from-gregorian today))))
	  (year (caddr yesterday))
	  (month (car yesterday))
	  (day (cadr yesterday)))
     (format "%04d-%02d-%02d" year month day))
   ))

(defun insert-dateunix ()
  (insert (current-time-string)))

(defun insert-time ()
  (insert (time-stamp-string "%02H:%02M:%02S") ))

(defun insert-datetime ()
  (insert-date) (insert " " ) (insert-time))

(defun insert-date-minutes ()
  (insert-date)
  (insert "/")
  (insert (time-stamp-string "%02H:%02M")))

(defun insert-copyright ()
  (let ((year (time-stamp-string "%:y")))
    (insert "Copyright (C) " year " " user-full-name ". All Rights Reserved.")
    ))


(require 'uuid nil t)

(defun insert-uuid ()
  (insert (uuid)))

(defun insert-short-uuid ()
  (insert (car (last (split-string (uuid) "-")))))

;; Generic global abbrevs.
(define-abbrev-table
  'global-abbrev-table
  '(
    ("env" "#!/usr/bin/env " nil 0)
    ("coding" ".. -*- coding: utf-8 -*-" nil 0)
    ("text" ".. -*- mode: text; fill-column: 80; truncate-lines: t -*-\n" nil 0)
    ("xmlhead" "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>" nil 0)

    ("rem" "TODO(blais): Remove" nil 0)
    ("todo" "TODO(blais): " nil 0)

    ("email" "" insert-email 0)
    ("author" "" insert-author 0)
    ("author2" "" insert-author-rev 0)
    ("time" "" insert-time 0)
    ("date" "" insert-date 0)
    ("today" "" insert-date 0)
    ("yesterday" "" insert-yesterday 0)
    ("dateunix" "" insert-dateunix 0)
    ("datetime" "" insert-datetime 0)
    ("datemin" "" insert-date-minutes 0)
    ("copyright" "" insert-copyright 0)
    ("uuid" "" insert-uuid 0)
    ("guid" "" insert-uuid 0)
    ("uid" "" insert-short-uuid 0)
    ("suuid" "" insert-short-uuid 0)
    ("shortuuid" "" insert-short-uuid 0)
    ("short-uuid" "" insert-short-uuid 0)
   ))


;;------------------------------------------------------------------------------
;; find-file support.

(require 'find-file)

;; Always open all files in read-only mode by default. I'm tired of accidental
;; fat-finger edits.
;(add-hook 'find-file-hook (lambda () (setq buffer-read-only t)))

(setq ff-always-try-to-create 'nil)
(setq find-file-existing-other-name t)
(setq find-file-visit-truename t)

(defun ff-check-exists-other-file ()
  (interactive)
  "Like ff-find-other-file, but just checks if the file on the current include
line exists and doesn't load the file."
  (let (fname dirs filename)
    (if ff-pre-find-hooks
        (run-hooks 'ff-pre-find-hooks))
    (message "Working...")
    (setq dirs
          (if (symbolp ff-search-directories)
              (ff-list-replace-env-vars (symbol-value ff-search-directories))
            (ff-list-replace-env-vars ff-search-directories)))
    (save-excursion
      (beginning-of-line 1)
      (setq fname (ff-treat-as-special)))

    (setq filename (ff-get-file-name dirs fname nil))

    (if filename
        (message (concat "File found: " filename))
      (message "File not found."))
    ))


(if (not (lookup-key (current-global-map) [(control c)(o)]))
    (progn
      (global-set-key* [(control c)(o)] 'ff-find-other-file)
      (global-set-key* [(control c)(l)] 'ff-check-exists-other-file)
      ))


(defmacro find-file-in-window-x (window)
  `(lambda ()
     (interactive)
     (select-window (nth ,window (window-list-stable)))
     (call-interactively 'ido-find-file)))

(define-key* ctl-x-4-map "1" (find-file-in-window-x 0))
(define-key* ctl-x-4-map "2" (find-file-in-window-x 1))
(define-key* ctl-x-4-map "3" (find-file-in-window-x 2))


;; ;; ** The new user-option `find-file-suppress-same-file-warnings' can be

;;------------------------------------------------------------------------------
;; winmgr interaction.

(defvar resize-column nil
  "Standard resize column.")
(make-variable-buffer-local 'resize-column)

(defun resize-width-to-fill-column ()
  "Resizes each window to its resize-column, or to fill-column if
not set."
  (interactive)
  ;;(set-frame-width (window-frame (selected-window)) user-default-frame-width))
  (let* ((width (or resize-column fill-column))
         (selwin (selected-window))
         (fr (window-frame (selected-window)))
         (cols 0))

    ;; Sum the total number of columns
    (dolist (w (window-list))
      (select-window w)

      ;; char width and leave one extra chars on the right
      (setq cols (+ cols width 1))

      ;; add space for the left an right reserved spaces
      (setq cols (+ cols 2))
      )

    ;; add space for the scroll bars, 2 chars each, say.
    (setq cols
          (+ cols (* (- (length (window-list)) 1) 5)))

    ;; Set the frame size
    (set-frame-width fr cols)

    ;; Set each of the windows sizes
    (dolist (w (window-list))
      (select-window w)
      (enlarge-window (- (+ width 1) (window-width)) t)
      )

    (select-window selwin)
    ))


;; 45678901234567890123456789012345678901234567890123456789012345678901234567890

(defun resize-width-to-fit ()
  "Resizes window to fit file width."
  (interactive)
  (let ( (maxcol 0) )
    (save-excursion
      (beginning-of-buffer)
      (while (not (= (point) (point-max)))
        (end-of-line)
        (setq maxcol (max maxcol (current-column)))
        (forward-line 1)
        ))
    (set-frame-width (window-frame (selected-window)) (+ maxcol 1))
    ))


(defun resize-width-maximize (dox doy)
   "Fix for broken maximize feature of Macs, where maximize does
not really mean maximize somehow (what is wrong with you
people?).  When I mean maximize, I mean MAXIMIZE, i.e. take the
whole frigging screen, ok?"
   (interactive)
   (let* ((frame (window-frame (selected-window)))
          (left (if dox 0 (frame-parameter frame 'left)))
          (top (if doy 0 (frame-parameter frame 'top)))
          (wh (cdr (assoc system-name maximized-frame-widths))))
     ;; Settings for the Macbook 2008.
     (when dox
       (set-frame-width frame (car wh)))
     (when doy
       (set-frame-height frame (cadr wh)))
     (set-frame-position frame left top)
     ))

;; To find out what the desktop size is:
;; (cons (window-width) (window-height))

(defvar maximized-frame-widths
  '(("banane" . (207 58))
    ("tangerine" . (179 53))
    ))

(global-set-key* [(control x)(meta x)]
                (lambda () (interactive) (resize-width-maximize nil t)))
(global-set-key* [(control x)(meta z)]
                (lambda () (interactive) (resize-width-maximize t t)))
(global-set-key* [(control x)(meta c)]
                (lambda () (interactive) (resize-width-maximize t nil)))

;; resize-width-to-fill-column
;; resize-width-to-fit
;; resize-width-maximize



;;------------------------------------------------------------------------------
;; Go to longest line of buffer

(defun goto-longest-line ()
  "Moves point to the first longest line in the current buffer."
  (interactive)
  (let ( (maxcol -1)
         (lpt) )
    (save-excursion
      (beginning-of-buffer)
      (while (not (= (point) (point-max)))
        (end-of-line)
        (if (> (current-column) maxcol)
            (progn
              (setq maxcol (current-column))
              (setq lpt (point))
              ))
        (forward-line 1)
        ))
    (and lpt (goto-char lpt))
    ))

(global-set-key* [(control c)(meta a)] 'goto-longest-line)



;;------------------------------------------------------------------------------
;; Unicode

;; Note: we do not use the functions provided by the xmlunicode package; they
;; are modal, for the most part, and my experience is that this has made them
;; really difficult to use. IMO my modeless bindings are much easier to learn
;; and use very quickly.

(when (require 'smartquotes nil t)
  (add-hook 'rst-mode-hook 'text-mode-smartquotes-hook) )

;; We do, however, use some of the xmlunicode stuff anyway.
(when (require 'xmlunicode nil t)
  (define-key* ctl-x-map [(U)] 'unicode-character-insert) )

;; Maybe replace the Multi_key binding by the more powerful
;; unicode-character-shortcut-insert?
;; Also: unicode provides this: (set-input-method 'xml)




;;------------------------------------------------------------------------------
;; Frames.

(defun other-window-all-frames ()
  (interactive)
  (let* ((w (next-window nil nil 'visible))
         (f (window-frame w)))
    ;; This is causing on Ubuntu 11.04 / compiz / synergy setup
    ;;(select-frame-set-input-focus f)
    (select-window w)
    ))

(when (featurep 'repeatable)
  (substitute-key-definition
   'other-window (repeatable-command-def 'other-window-all-frames)
   (current-global-map)) )

;; Note: do not use (meta tab) because that is bound by the window manager to
;; emulate windows-like behaviour.
;;;  (global-set-key* [(control x)(shift o)] 'other-frame)

;;(global-set-key* [(shift f8)] 'delete-frame-and-inform-client)
;;(global-set-key* [(control meta f8)] 'delete-frame-and-buffer)



;; Functions to directly select a specific window.
(defun window-list-stable ()
  (window-list-rec (car (window-tree))))

(defun window-list-rec (w)
  ;; Note: W can be either a window, or a list of (DIR, EDGES, WINDOWS).
  ;: Returns a flattened list of windows.
  (if (listp w)
      (apply 'append (mapcar 'window-list-rec (cddr w)))
    (list w)))

(defun make-select-nth-window (n)
  `(lambda () (interactive) (select-window (nth ,n (window-list-stable)))))

(progn
  (define-key* global-map [(meta \1)] (make-select-nth-window 0))
  (define-key* global-map [(meta \2)] (make-select-nth-window 1))
  (define-key* global-map [(meta \3)] (make-select-nth-window 2))
  (define-key* global-map [(meta \4)] (make-select-nth-window 3))

  (define-key* global-map [(meta shift q)] (make-select-nth-window 0))
  (define-key* global-map [(meta shift w)] (make-select-nth-window 1))
  (define-key* global-map [(meta shift e)] (make-select-nth-window 2))
  (define-key* global-map [(meta shift r)] (make-select-nth-window 3))

  (define-key* global-map [(control c)(\1)] (make-select-nth-window 0))
  (define-key* global-map [(control c)(\2)] (make-select-nth-window 1))
  (define-key* global-map [(control c)(\3)] (make-select-nth-window 2))
  (define-key* global-map [(control c)(\4)] (make-select-nth-window 3))

  (define-key* global-map [(meta shift \q)] (make-select-nth-window 0))
  (define-key* global-map [(meta shift \w)] (make-select-nth-window 1))
  (define-key* global-map [(meta shift \e)] (make-select-nth-window 2))
  (define-key* global-map [(meta shift \r)] (make-select-nth-window 3))

  (define-key* global-map [(control z)(\q)] (make-select-nth-window 0))
  (define-key* global-map [(control z)(\w)] (make-select-nth-window 1))
  (define-key* global-map [(control z)(\e)] (make-select-nth-window 2))
  (define-key* global-map [(control z)(\r)] (make-select-nth-window 3))
  )





;;------------------------------------------------------------------------------
;; Compilation.

(require 'compile)

(define-key* compilation-mode-map [(control c)(control c)] nil)

(setq-default compile-command "make")

(setq compilation-window-height 15
      compilation-read-command t
      compilation-scroll-output t
      compilation-ask-about-save nil ;; Saves all buffers automatically
      )

(defadvice read-shell-command (around save-buffer-file-name activate)
  "Allow us to insert the invoking buffer's filename from the minibuffer when
reading shell commands."
  (let ((shell-command-invocation-buffer-filename (buffer-file-name))
	(shell-command-invocation-buffer-directory default-directory))
    ad-do-it
    ))

;; Commands to run in the 'compile buffer.

(defun shell-command-insert-invocation-buffer-filename ()
  "Insert the name of the buffer which invoked this command."
  (interactive)
  (insert (or shell-command-invocation-buffer-filename
	      shell-command-invocation-buffer-directory)))

(defun shell-command-reset-cwd-new-command (&optional command)
  "Reset the buffer with a cd command to the directory of the
file which invoked compilation."
  (interactive)
  (delete-region (line-beginning-position) (line-end-position))
  (insert (format "cd %s && "
                  (directory-file-name shell-command-invocation-buffer-directory)))
  (when command (insert command)))

(defun shell-command-reset-root-new-command (&optional command)
  "Reset the buffer with a cd command to the root of the
repository of the file which invoked compilation."
  (interactive)
  (delete-region (line-beginning-position) (line-end-position))
  (let ((backend (vc-backend shell-command-invocation-buffer-filename)))
    (when backend
      (let ((rootdir (vc-call-backend backend 'root default-directory)))
        (insert (format "cd %s && " (expand-file-name (directory-file-name rootdir)))))))
  (when command (insert command)))

(defun shell-command-insert-grep-command ()
  (interactive)
  (delete-region (line-beginning-position) (point))
  (let ((prefix "grep --exclude-from=$HOME/p/conf/etc/grep-excludes -srn  "))
    (insert (format "%s  %s" prefix (directory-file-name default-directory)))
    (beginning-of-line)
    (forward-char (length prefix))))

(when (boundp 'minibuffer-local-shell-command-map)
  (define-key* minibuffer-local-shell-command-map [(control meta i)]
    'shell-command-reset-cwd-new-command)
  (define-key* minibuffer-local-shell-command-map [(control shift i)]
    'shell-command-reset-root-new-command)
  (define-key* minibuffer-local-shell-command-map [(control c)(i)]
    'shell-command-insert-invocation-buffer-filename)
  (define-key* minibuffer-local-shell-command-map [(control c)(g)]
    'shell-command-insert-grep-command) )

(define-key* goto-map [(e)] 'compile-goto-error)

;;(global-set-key* [(control c)(control c)] 'compile) ;; The one Monnier likes, bad because it clashes with many others
(global-set-key* [(control c)(c)] 'compile)
(global-set-key* [(control c)(k)] 'kill-compilation)
;;(global-set-key* [(control c)(control k)] 'kill-compilation)

;; (define-key* goto-map [(c)] 'compile) ;; Tentative
;; (define-key* goto-map [(j)] 'compile) ;; Tentative
;; (define-key* goto-map [(?9)] 'compile) ;; Like legacy
;; (define-key* goto-map [(k)] 'kill-compilation) ;; Tentative

(when (featurep 'repeatable)
  (repeatable-command-advice next-error)
  (repeatable-command-advice previous-error) )


(defun rename-compilation-buffer ()
  "Renames existing *compilation* buffer for new compilation job."
  (interactive)
  (save-excursion
    (when (get-buffer "*compilation*")
      (set-buffer "*compilation*")
      (rename-uniquely))))

(global-set-key* [(control c)(d)] (rename-compilation-buffer))




;;------------------------------------------------------------------------------
;; Makefiles.

 ;; imake
(add-to-list 'auto-mode-alist '("/[iI]?[mM]akefile[^/]*$" . makefile-mode))

(require 'make-mode)
(define-key* makefile-mode-map [(meta n)] 'user-next-some-lines)
(define-key* makefile-mode-map [(meta p)] 'user-previous-some-lines)


;;------------------------------------------------------------------------------
;; GNU global / gtags

(require 'etags)
(setq tags-revert-without-query t)


(when nil  ;; Stop installing gtags because it does not support Python.
           ;; Use exuberant-ctags instead.

  (load "gtags.el")
  ;; (autoload 'gtags-mode "gtags" "" t)


  ;; Don't set in gtags mode because that overrides mouse bindings!!!
  ;; instead bind static bindings to it.
  ;;(setq c-mode-common-hook '(lambda () (gtags-mode 1) ))

  (global-set-key* [(meta \.)] 'gtags-find-tag)

  ;; Ditch the gtags bindings
  ;; (setq gtags-mode-map nil)

  (defvar ctl-dot-map (make-sparse-keymap) "Keymap for gtags commands.")
  (defalias 'ctl-dot-prefix ctl-dot-map)

  (global-set-key* [(control \.)] 'ctl-dot-prefix)

  (define-key* ctl-dot-map [(h)] 'gtags-display-browser)
  (define-key* ctl-dot-map [(c)] 'gtags-make-complete-list)
  (define-key* ctl-dot-map [(\])] 'gtags-find-tag-from-here)
  (define-key* ctl-dot-map [(t)] 'gtags-pop-stack)
  (define-key* ctl-dot-map [(l)] 'gtags-find-file)
  (define-key* ctl-dot-map [(g)] 'gtags-find-with-grep)
  (define-key* ctl-dot-map [(I)] 'gtags-find-with-idutils)
  (define-key* ctl-dot-map [(s)] 'gtags-find-symbol)
  (define-key* ctl-dot-map [(r)] 'gtags-find-rtag)
  (define-key* ctl-dot-map [(t)] 'gtags-find-tag)

  (defun downcase-first-char (s)
    (concat (downcase (substring s 0 1)) (substring s 1)))

  (defun gtags-find-file-at-point ()
    "Like gtags-find-file, but automatically tries to construct a filename
with the word at point and invokes gtags-find without prompt."
    (interactive)
    (let ((tap (thing-at-point 'word)))
      (if tap
          (progn
            (message tap)
            (setq tap (concat (downcase-first-char tap) ".h"))
            (gtags-push-context)
            (gtags-goto-tag tap "P")))
      ))

  (define-key* ctl-dot-map [(control l)] 'gtags-find-file-at-point)

  )


;;------------------------------------------------------------------------------
;; ctags / Exuberant ctags

;; No special file is needed.

(when (featurep 'repeatable)
  (repeatable-command-advice find-tag) )


;;------------------------------------------------------------------------------
;; doxygen support.

(require 'doxymacs nil t)


;;------------------------------------------------------------------------------
;; cc-mode (C, C++, Java, Objective-C)

(require 'cc-mode)

;; (setq c-echo-syntactic-information-p t)

(setq-default c-backslash-max-column 120)

;; Boost has some .ipp files.
(add-to-list 'auto-mode-alist '("\\.ipp$" . c++-mode))


;; Note: This has to be done BEFORE loading cc-mode
(setq c-style-variables-are-local-p t)

;;(autoload 'c++-mode "cc-mode" "Major mode for editing C++." t)
;;(autoload 'c-mode "cc-mode" "Major mode for editing C." t)
;;(require 'cc-mode)

;;
;; My default C/C++ style.
;;
(defun user-cc-snug-close (syntax pos)
  (save-excursion
    (let (langelem)
      (if (and (eq syntax 'block-close)
               (setq langelem (assq 'block-close c-syntactic-context))
               (progn (goto-char (cdr langelem))
                      (if (eq (char-after) ?{)
                          (c-safe (forward-sexp -1)))
                      (or (looking-at "\\<do\\>[^_]")
                          (looking-at "\\<case\\>[^_]"))))
          '(before)
        '(before after)))))

(defun user-cc-class-open (syntax pos)
  (save-excursion
    (progn (goto-char pos)
           (if (or (looking-at "^namespace\\>")
                   (save-excursion
                   (progn (forward-word -2)
                          (looking-at "^namespace\\>")))
                   (save-excursion
                     (progn (forward-word -1)
                            (looking-at "^namespace\\>"))))
               '(after)
             '(before after)))))

(defconst user-cc-style
  (let ((tmp-user-cc-style

  '((indent-tabs-mode . nil)
    (c-basic-offset . 2)
    (c-hanging-braces-alist       . ((class-open        . user-cc-class-open)
                                     (class-close         before)
                                     (defun-open          before after)
                                     (defun-close         before after)
                                     (inline-open         before after)
                                     (inline-close        before after)
                                     (brace-list-open     after)
                                     (brace-list-close    before)
                                     (block-open          before after)
                                     (block-close       . user-cc-snug-close)
                                     (substatement-open   after)
                                     (substatement-close  before after)
                                     (statement-case-open after)
                                     (extern-lang-open    after)
                                     (extern-lang-close   before after)))
    (c-hanging-colons-alist       . ((case-label          )
                                     (label               after)
                                     (access-label        after)
                                     (member-init-intro   before)
                                     (inher-intro         before)))
    (c-cleanup-list               .  (empty-defun-braces
                                      defun-close-semi
                                      list-close-coma
                                      scope-operator))
    (c-offsets-alist . ((string                . -1000)
                        (c                     . c-lineup-C-comments)
                        (defun-open            . 0)
                        (defun-close           . 0)
                        (defun-block-intro     . +)
                        (class-open            . 0)
                        (class-close           . 0)
                        (inline-open           . 0)
                        (inline-close          . 0)
                        (func-decl-cont        . +)
                        (knr-argdecl-intro     . +)
                        (knr-argdecl           . 0)
                        (topmost-intro         . 0)
                        (topmost-intro-cont    . 0)
                        (member-init-intro     . +)
                        (member-init-cont      . 0)
                        (inher-intro           . +)
                        (inher-cont            . c-lineup-multi-inher)
                        (block-open            . 0)
                        (block-close           . 0)
                        (brace-list-open       . 0)
                        (brace-list-close      . 0)
                        (brace-list-intro      . +)
                        (brace-list-entry      . 0)
                        (statement             . 0)
                        (statement-cont        . +)
                        (statement-block-intro . +)
                        (statement-case-intro  . +)
                        (statement-case-open   . +)
                        (substatement          . +)
                        (substatement-open     . +)
                        (case-label            . +)
                        (access-label          . -)
                        (label                 . 0)
                        (do-while-closure      . 0)
                        (else-clause           . 0)
                        (comment-intro         . c-lineup-comment)
                        (arglist-intro         . 4)
                        (arglist-cont          . 0)
                        (arglist-cont-nonempty . c-lineup-arglist)
                        (arglist-close         . 0)
                        (stream-op             . c-lineup-streamop)
                        (inclass               . +)
                        (cpp-macro             . -1000)
                        (friend                . 0)
                        (objc-method-intro     . -1000)
                        (objc-method-args-cont . c-lineup-ObjC-method-args)
                        (objc-method-call-cont . c-lineup-ObjC-method-call)
                        (extern-lang-open      . 0)
                        (extern-lang-close     . 0)
                        (inextern-lang         . 0)
                        (template-args-cont    . +)
			(cpp-macro-cont        . c-lineup-dont-change)
			(namespace-open        . 0)
			(namespace-close       . 0)
			(innamespace           . 0)
			))) ))
    tmp-user-cc-style)
  (concat user-full-name " default programming style"))


;; FIXME: There must be a way to change the default without having to add a new
;; style. Do it.
(let ((style-name "user-default"))
  (c-add-style style-name user-cc-style)
  (aput 'c-default-style 'c-mode style-name)
  (aput 'c-default-style 'c++-mode style-name)
  (aput 'c-default-style 'java-mode style-name))



;;
;; C/C++ style used for Python code.
;;
(c-add-style
 "python-new"
 '((indent-tabs-mode . nil)
   (fill-column      . 78)
   (c-basic-offset   . 2)
   (c-offsets-alist  . ((substatement-open . 0)
                        (inextern-lang . 0)
                        (arglist-intro . +)
                        (knr-argdecl-intro . +)))
   (c-hanging-braces-alist . ((brace-list-open)
                              (brace-list-intro)
                              (brace-list-close)
                              (brace-entry-open)
                              (substatement-open after)
                              (block-close . c-snug-do-while)))
   (c-block-comment-prefix . ""))
 )



;; Add keywords for Qt classes.
(push "Q[A-Z][A-Za-z0-9]+" c++-font-lock-extra-types)





(require 'font-lock)


;; Objective C for default settings in Xcode.
(defun user-objc-mode-hook ()
  (setq tab-width 4
        abbrev-mode nil)
  )
(add-hook 'objc-mode-hook 'user-objc-mode-hook)


(defun user-c-mode-common-hook ()

  ;; FIXME don't do this here anymore.
  ;;(c-add-style user-full-name user-cc-style t)

  ;; Iffset customizations not in user-c-style.
  ;;(c-set-offset 'member-init-intro '++)

  ;; Other customizations
  (setq ;; tab-width 8
        ;; This will make sure spaces are used instead of tabs
        indent-tabs-mode nil
	abbrev-mode nil
	)

  ;; We like auto-newline and hungry-delete
  ;; (c-toggle-auto-hungry-state 1)

  ;; Keybindings for all supported languages.  We can put these in
  ;; c-mode-base-map because c-mode-map, c++-mode-map, objc-mode-map,
  ;; java-mode-map, and idl-mode-map inherit from it.

  (when nil ;; FIXME: Disabled, this breaks the dabbrevs within Google smoehow.
    ;; Set this up when you have variables that start both with _ and without
    ;; (like Dante data members).
    (setq dabbrev-abbrev-skip-leading-regexp "\\(m_\\|_\\|get\\|set\\)")
    )


  ;; If you want TAB that is not that the end of a line to perform dabbrev
  ;; (or something else):
  ;;
  ;;(setq c-tab-always-indent nil)
  ;;(setq c-insert-tab-function '(lambda () (dabbrev-expand 1)))

  )


;; Remove erroneous default binding for comment-region in c-mode.
(define-key* c-mode-base-map [(control c)(control c)] nil)

;; See functions below.
(define-key* c-mode-base-map [(meta \")] 'comment-dwim-c-toggle) ;; FIXME: This does not work yet, figure out how to assign it.
(define-key* c-mode-base-map [(control c)(control u)] 'c-ifdef-toggle)

(define-key* c-mode-base-map [(meta ^)] 'delete-indentation-no-fixup)
(define-key* c-mode-base-map [(meta &)] 'indent-after-comma-or-paren)

(add-hook 'c-mode-common-hook 'user-c-mode-common-hook)

(defun comment-dwim-c-toggle ()
  "Toggle C-style comment in a region. If the region is active, add comment,
otherwise remove enclosing comment."
  (interactive)
  (let ((comm-begin "/*")
        (comm-end "*/"))
    (if mark-active
        (progn
          (or (> (point) (mark)) (exchange-point-and-mark))
          (let ( (begin (region-beginning))
                 (end (region-end)) )
            (goto-char end) (insert comm-end)
            (goto-char begin) (insert comm-begin)
            ))
      (progn
        (let ( orig begin end )
          (save-excursion
            (setq orig (point))
            (search-backward comm-begin)
            (setq begin (point))
            (search-forward comm-end)
            (setq end (point))
            (if (and (< begin orig) (< orig end))
                (progn
                  (delete-backward-char (length comm-end))
                  (goto-char begin)
                  (delete-char (length comm-begin)))
              (message "Error: not inside a C-style comment.")
              ))
          ))
      )))

;; Defined in newcomment.el.  You can choose different styles of region
;; commenting with the variable `comment-style'.


(add-to-list 'auto-mode-alist '("\\(CHANGES\\|TODO\\|README\\)" . text-mode))

;; Add pattern for ACE inline includes.
(add-to-list 'auto-mode-alist '("\\.inl$" . c++-mode))


;;------------------------------------------------------------------------------
;; C#

(autoload 'csharp-mode "csharp-mode" "Major mode for editing C# code." t)



;;------------------------------------------------------------------------------
;; Octave

(add-to-list 'auto-mode-alist '("\\.m$" . octave-mode))



;;------------------------------------------------------------------------------
;; Detection of errors for compilation

(when (boundp 'compilation-error-regexp-alist-alist)

  ;; Modify GNU compiler error detection to include files that start with an
  ;; underscore, as this often the case for Python extension modules.
  (let ((rule (assoc 'gnu compilation-error-regexp-alist-alist)))
    (setcar (cdr rule)
  	    (replace-regexp-in-string (format "\\(%s\\)\\(.\\|\n\\)*\\'" (regexp-quote "[/.]"))
  				      "[/._]" (cadr rule) nil nil 1)
            ))

  ;; ;; A fix for an invalid regexp for gcc, which has too greedy a regexp.
  ;; (let ((rule (assoc 'gcc-include compilation-error-regexp-alist-alist)))
  ;;   (setcar (cdr rule)
  ;; 	    (replace-regexp-in-string "\\(\\.\\+\\)"
  ;; 				      "[^:]+" (cadr rule) nil nil 1)
  ;;    ))

  ;; Support parsing Python logging errors, with a suitable logging.basicConfig()
  ;; format.
  (unless (assq 'python-logging compilation-error-regexp-alist-alist)
    (add-to-list
     'compilation-error-regexp-alist-alist
     '(python-logging "^\\(ERROR\\|WARNING\\)\\s-*:\\s-*\\([^:]+\\):\\([0-9]+\\)\\s-*:" 2 3))
    (add-to-list 'compilation-error-regexp-alist 'python-logging) )

  )


(defun delete-indentation-no-fixup (&optional arg)
  "Calls delete-indentation and ensures just-one-space at join point."
  (interactive "*P")
  (call-interactively 'delete-indentation)
  (let ((pre (or (eq (preceding-char) ?\()
                 (eq (preceding-char) ?\{)))
        (fol (or (eq (following-char) ?\))
                 (eq (following-char) ?\}))))
    (and (or pre fol)
         (not (and pre fol))
         (just-one-space))
    ))

(defun indent-after-comma-or-paren (&optional arg)
  "Searches for the next comma or closing parenthesis, newlines and indents.
This is useful for spreading function call parameters over multiple lines."
  (interactive "*P")
  (re-search-forward "\\(,\\|)\\|(\\)")
  (let* ((beg (match-beginning 1))
         (bss (buffer-substring beg (+ beg 1))))
    (cond ((string-match "(" bss)
           (backward-char) (forward-sexp) (indent-after-comma-or-paren arg))
          ((string-match "," bss)
           (newline-and-indent))
          ((string-match ")" bss)
           (backward-char) (newline-and-indent))
          )))

(defun end-of-line-for-c-with-comments ()
  (interactive)
  "Goes to end of line if there is no c comment after.
If a c comment is present, goes to end of c code line, or if there
is nothing before, goes to end of line."

  (if (equal last-command 'end-of-line-for-c-with-comments)
      (end-of-line)
    (if (search-forward-regexp "/\\*\\|//"
                               (save-excursion (end-of-line) (point))
                               'placepointtolimit)
        (progn
          (backward-char 2)
          (if (equal (re-search-backward "[^ \t]"
                                         (save-excursion
                                           (beginning-of-line) (point)) t) nil)
              (end-of-line)
            (forward-char 1))))))

(defvar c-ifdef-history nil)

(defun c-ifdef-toggle ()
  "Toggle ifdef a region. With active region, add ifdef, otherwise remove.  With
prefix arg, ask for expression"
  (interactive)
  (if mark-active
      (progn
        (let ( (beg (region-beginning))
               (end (region-end))
               (condition nil) )
          (if current-prefix-arg
              (setq condition (read-string "#ifdef " c-ifdef-history)))
          (goto-char end)
          (insert "#endif\n")
          (goto-char beg)
          (if condition
              (insert "#ifdef " condition "\n")
            (insert "#if 0 \n")
            )))
    (progn
        (let ( beg end )
          (c-up-conditional 1)
          (setq beg (point))
          (c-forward-conditional 1)
          (previous-line 1)
          (setq end (point))
          (goto-char end)
          (beginning-of-line)
          (kill-whole-line)
          (goto-char beg)
          (beginning-of-line)
          (kill-whole-line)))
    ))


;;------------------------------------------------------------------------------
;; JavaScript

;; Note: Ubuntu already does this automatically. apt-get.
;;(add-to-list 'auto-mode-alist (cons "\\.js$" 'js2-mode))

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(auth-source-save-behavior nil)
 '(blink-cursor-mode t)
 '(c++-font-lock-extra-types (append '("Q[A-Z][a-zA-Z0-9]+") c++-font-lock-extra-types))
 '(column-number-mode t)
 '(custom-safe-themes
   '("40f6a7af0dfad67c0d4df2a1dd86175436d79fc69ea61614d668a635c2cd94ab" "d677ef584c6dfc0697901a44b885cc18e206f05114c8a3b7fde674fce6180879" "8aebf25556399b58091e533e455dd50a6a9cba958cc4ebb0aab175863c25b9a4" default))
 '(frame-background-mode 'dark)
 '(gud-gdb-command-name "gdb --annotate=1")
 '(js2-auto-indent-p nil)
 '(js2-mirror-mode nil)
 '(js2-mode-escape-quotes nil)
 '(js2-mode-squeeze-spaces nil)
 '(js2-rebind-eol-bol-keys nil)
 '(large-file-warning-threshold nil)
 '(menu-bar-mode nil)
 '(nxml-child-indent 2)
 '(package-selected-packages
   '(tuareg go-mode go-imports bazel ace-isearch ace-link ace-jump-buffer ace-jump-helm-line ace-jump-mode ace-jump-zap websocket simple-httpd pylint pytest pytest-pdb-break python-info python-mode python-pytest python-x xmlunicode markdown-mode markdown-mode+ markdownfmt font-lock-studio protobuf-mode yaml-mode go-stacktracer go-snippets go-scratch go-projectile go-playground-cli go-playground go-impl go-gopath go-errcheck go-dlv go-direx go-complete go-autocomplete go-add-tags))
 '(show-paren-mode t)
 '(tool-bar-mode t))

;; Gnus / email


;; Using MozRepl
(autoload 'moz-minor-mode "moz" "Mozilla Minor and Inferior Mozilla Modes" t)


(defun user-js-mode-hook ()
  (moz-minor-mode 1))

(add-hook 'js2-mode-hook 'user-js-mode-hook)



;; Abbrevs for JavaScript
(let ((table-defn `(
		    ("al" "alert();" nil 0)
		    ("log" "" ,(make-abbrev-inserter "console.log(\"% = \" + %);") 0)
		    ("fun" "" ,(make-abbrev-inserter "var % = function () {\n@\n}") 0)
		    )))
  (dolist (table '(html-mode-abbrev-table js-mode-abbrev-table))
    (define-abbrev-table table table-defn)))



;;------------------------------------------------------------------------------
;; extensions to find-file for .h .inline.h .ccp (file families)

(if (require 'family-find-file2 nil t)
    (progn
      (global-set-key* [(control c)(o)] 'family-find-other-file)
      )
  (progn
    (global-set-key* [(control c)(o)] 'ff-find-other-file)
    (setq cc-other-file-alist
	  (mapcar (lambda (x) (list (format "\\.%s$" x) (list x)))
		  '("cpp" "hpp" "C" "H" "c" "h")))
    ))


;; Add the STL directory for find-file
(defvar most-recent-stl-dir nil
  "The highest numbered C++ STL directory under Linux.")
(when (file-exists-p "/usr/include/c++")
  (setq most-recent-stl-dir
	(car (last (directory-files "/usr/include/c++" t nil nil))))

  (add-to-list 'cc-search-directories most-recent-stl-dir t)
  ;;(setq ff-case-fold-search t)
  )


;;------------------------------------------------------------------------------
;; insert-trace

(defvar insert-trace-longest-kill 5
  "Value of longest kill ring that will be used in an interactive request for
trace statement insertion")

(defvar insert-trace-outstream "std::cout")
(defvar insert-trace-endl "std::endl")

(defun insert-trace (varname &optional stream)
  "Inserts a trace statement for tracing a message."
  (interactive
   (let ((varname
	  (read-string "Insert trace variable: "
		       (if (< (length (current-kill 0 't))
			      insert-trace-longest-kill)
			   (current-kill 0 't)
			 nil)
		       'insert-trace-variable-history)))
     (list varname)))
  (let ((stream (or stream insert-trace-outstream)))
    (cond ((equal current-prefix-arg nil)
	   (insert (concat
		    stream " << \""
		    varname
		    "\" << " insert-trace-endl ";\n")))
	  ((or (listp current-prefix-arg)
	       (equal current-prefix-arg 1))
	   (insert (concat stream " << \"" varname "=\" << " varname
			   " << " insert-trace-endl ";\n"))))))

(defun insert-trace-value (varname)
  "Inserts a trace statement for tracing a variable."
  (interactive
   (let ((varname
          (read-string "Insert trace variable: "
                       (if (< (length (current-kill 0 't))
                              insert-trace-longest-kill)
                           (current-kill 0 't)
                         nil)
                       'insert-trace-variable-history)))
     (list varname)))
  (cond ((equal current-prefix-arg nil)
         (insert (concat
                  insert-trace-outstream " << \""
                  varname
                  " = \" << "
                  varname
		  " << " insert-trace-endl ";\n")))
        ((or (listp current-prefix-arg)
             (equal current-prefix-arg 1))
         (insert (concat insert-trace-outstream " << \"" varname "=\" << " varname
                         " << " insert-trace-endl ";\n")))))

(defun insert-trace-counter ()
  "Inserts a trace statement for the last variable inserted with
a counter that automatically increases."
  (interactive)
  (let ((varname (car insert-trace-variable-history)))
    (cond ((equal current-prefix-arg nil)
	   (insert (concat
		    insert-trace-outstream " << \""
		    varname
		    " = \" << \""))
	   (kmacro-insert-counter 1)
	   (insert (concat "\" << " insert-trace-endl ";\n")))
	  ((or (listp current-prefix-arg)
	       (equal current-prefix-arg 1))
	   (insert (concat insert-trace-outstream" << \"" varname "=\" << " varname
			   " << " insert-trace-endl ";\n"))))))

(defun insert-stl-begin-end (varname)
  "Insert STL begin() / end() accessors."
  (interactive
   (let ((varname
          (read-string "Container variable: "
                       (if (< (length (current-kill 0 't))
                              insert-trace-longest-kill)
                           (current-kill 0 't)
                         nil)
                       'insert-trace-variable-history)))
     (list varname)))
  (progn
    (insert (concat varname ".begin()"))
    (insert "; ")
    (insert (concat varname ".end()"))))

(defvar cc-default-main
  "
int main( int argc, char** argv )
{
    return 0;
}
")


;; FIXME: We should move towards functions like this one.
(defmacro make-trace-expression (fmt n)
  "Inserts a trace statement for tracing a variable."
  `(lambda ()
     (interactive)
     (let ((varname
	    (read-string "Expression: "
			 (if (< (length (current-kill 0 't))
				insert-trace-longest-kill)
			     (current-kill 0 't)
			   nil)
			 'insert-trace-variable-history)))
       (insert (apply 'format (append (list ,fmt)
				      (make-list ,n varname)))))))



(defun get-current-cpp-function-name ()
  (interactive)
  (save-excursion
    ;; This is a lame way to get the function name; eventually use the cc-mode
    ;; function (which is broken right now in emacs 23 b/c of namespaces).
    (search-backward "::")
    (search-backward " ")
    (let ((p (1+ (point))))
      (search-forward "(")
      (buffer-substring p (1- (point))))))



;; Define some useful abbreviations for these.
(define-abbrev-table
  'c++-mode-abbrev-table
  `(
   ("inc" "#include <>" nil 0)
   ("usi" "using namespace " nil 0)
   ("using" "using namespace " nil 0)
   ("bo" "boost::" nil 0)
   ("shp" "boost::shared_ptr" nil 0)
   ("aup" "std::unique_ptr" nil 0)
   ("str" "std::string" nil 0)
   ("vec" "std::vector" nil 0)
   ("lis" "std::list" nil 0)
   ("map" "std::map" nil 0)
   ("hmap" "std::unordered_map" nil 0)
   ("hset" "std::unordered_set" nil 0)
   ("ass" "BOOST_ASSERT(" nil 0)
   ("ver" "BOOST_VERIFY(" nil 0)
   ("tr" "" ,(make-abbrev-inserter "std::cout << \"%\" << std::endl;") 0)
   ("tv" ""   ,(make-abbrev-inserter "std::cout << \"% = '\" << % << \"'\" << std::endl;") 0)
   ("cout" "" ,(make-abbrev-inserter "std::cout << \"% = '\" << % << \"'\" << std::endl;") 0)
   ("cerr" "" ,(make-abbrev-inserter "std::cerr << \"% = '\" << % << \"'\" << std::endl;") 0)
   ("be" "" ,(make-abbrev-inserter "%.begin(); %.end()") 0)
   ("foreach" "" ,(make-abbrev-inserter "for ( auto it = %.begin(); it != %.end(); ++it ) {}") 0)
   ("tc" "" (lambda () (call-interactively 'insert-trace-counter)) 0)
   ("main" "" (lambda () (insert cc-default-main)) nil 0)
   ("xp" "" ,(make-abbrev-inserter "experimental") 0)
   ("exp" "" ,(make-abbrev-inserter "experimental") 0)
   ))



(defun insert-java-trace (varname)
  "Inserts a trace statement for tracing a variable."
  (interactive
   (let ((varname
          (read-string "Insert trace variable: "
                       (if (< (length (current-kill 0 't))
                              insert-trace-longest-kill)
                           (current-kill 0 't)
                         nil)
                       'insert-trace-variable-history)))
     (list varname)))
  (let ((varname (or varname "")))
    (insert (format "System.out.println(\"%s = \" + %s);\n" varname varname))))

(define-abbrev-table
  'java-mode-abbrev-table
  (list
   '("rem" "// FIXME: remove" nil 0)
   '("tv" "" (lambda () (call-interactively 'insert-java-trace)) 0)
   ;; '("tr" "System.out.println();" nil 0)
   ))



;;------------------------------------------------------------------------------
;; Version Control support.
;; See also xxdiff section.

(setq vc-follow-symlinks t) ;; default=ask

;; Use this for cvs
;; (setq vc-command-messages 't)
;; (setq vc-checkin-switches '("-u" "-NStable"))
;; (setq vc-checkout-switches '("-l -rStable"))

(setq vc-cvs-stay-local nil)
;; (require 'cvs-status))
;; The new user option `vc-cvs-use-edit' indicates whether VC should call

;; Restore my normal read-only toggle binding.
(global-set-key* [(control x)(control q)] 'read-only-mode)
(define-key* vc-prefix-map [(q)] 'vc-toggle-read-only)


;;------------------------------------------------------------------------------
;; version control

;; version control: Subversion

;;(add-to-list 'vc-handled-backends 'SVN)
;;(require 'psvn)

(when (eq window-system 'w32)
  (setq vc-svn-program-name "C:/Cygwin/lib/subversion/bin/svn.exe"))

(require 'vc-svn nil t)

(defun vc-diff-find-root ()
  "Find a line the specifies the root directory for a list of
files in the current dir."
  (save-excursion
    (beginning-of-buffer)
    (when (re-search-forward "^ROOT: \\(.*\\)$" nil t)
      (match-string 1))))

(defun filename-on-current-line ()
  "Return the first filename-like word on the current line.
Returns an absolute filename; if the filename is relative, it prepends
the current buffer's directory."
  (let ((line (thing-at-point 'line)))
    (when (string-match "\\([A-Za-z0-9/_\\.-]+/[A-Za-z0-9/_\\.-]+\\)" line)
      (let ((fn (match-string 1 line)))
	(if (file-relative-name fn)
	    (let ((root (vc-diff-find-root)))
	      (concat (if root root (file-name-directory (buffer-file-name))) "/" fn))
	  fn))
      )))

(defun vc-diff-at-point-get-vc ()
  (save-excursion
    (beginning-of-line)
    (let ((s (buffer-substring (point) (+ 3 (point)))))
      (cond ((string= s "HGC") 'hg)
	    (t 'svn)))
    ))

(defun vc-diff-at-point ()
  "Run an xxdiff command on the filename found on the current line."
  (interactive)
  (let ((fn (filename-on-current-line)))
    (when (and fn (file-exists-p fn))
      (let ((vc (vc-diff-at-point-get-vc)))
	(cond ((eq vc 'hg)
	       (call-process "hg" nil nil t "xdiff" "-q" fn))
	      ((eq vc 'svn)
	       (call-process "xx-svn-diff" nil '(nil "/tmp/output.txt") t "-O" "-w" "-O" "-b" fn)))
      ))))

(defun vc-git-diff-visual (files &optional rev1 rev2 buffer)
  "Overridden visual diff in order to get a visual diff"
  (let (process-file-side-effects)
    (apply #'vc-git-command (or buffer "*vc-diff*") 1 files
	   "difftool" ;; (difftool will get a visual diff, but diff-index/tree won't.)
	   "--exit-code"
	   (append (vc-switches 'git 'diff)
		   (list "-p" (or rev1 "HEAD") rev2 "--"))
	   )))

(defun vc-diff-current-here ()
  "Either xxdiff the current file or the filename at point."
  (interactive)
  (unless (vc-diff-at-point)
    (let* ((fn (buffer-file-name))
           (backend (vc-backend fn))
           (outbuf (get-buffer-create "*hg-output*")))
      (cond ((eq backend 'SVN)
	     (xxdiff-svn-diff))
	    ((eq backend 'Hg)
             (let ((default-directory (file-name-directory fn)))
               (call-process "hg" nil outbuf t "tmuxdiff" "-q" fn)))
	    ((eq backend 'Git)
	     (vc-git-diff-visual fn))
            ((eq backend nil)
             (when (string-match "/google3/" fn)
               (user-g4-diff-this-file fn)))
             )
      )))

(define-key* vc-prefix-map [(?p)] 'vc-diff-current-here)


(defun xx-vc-diff (historic &optional not-urgent)
  "A binding for invoking xxdiff directly from vc-dir-mode."
  (interactive (list current-prefix-arg t))
  (if historic
      (call-interactively 'vc-version-diff)
    (when buffer-file-name (vc-buffer-sync not-urgent))
    (let* ((vc-fileset (vc-deduce-fileset t))
	   (file (caadr vc-fileset)))
      (unless (= 0 (call-process "hg" nil t "*hg-output*" "xdiff" "-q" file))
	(message "Could not run hg.")))))

(require 'vc-dir)
;;(define-key* vc-dir-mode-map [(?+)] 'xx-vc-diff)
;;(define-key* vc-dir-mode-map [(?U)] 'vc-revert)


;; version control: Git
(when (add-first-found-to-load-path (concat home "/src/magit"))
  (autoload 'magit-status "magit" "Mode to interact with Git." t)
  )


;;------------------------------------------------------------------------------
;; diff/ediff

;; Source ediff standalone config.
;; (load (concat (file-truename load-file-name) ".ediff") t)


;;------------------------------------------------------------------------------
;; Compare kill-ring or register with an external diff program.

(defun external-diff (diff-executable text1 text2)
  "Compare two pieces of text using an external diff tool."
  ;; Create temporary files.
  (let ((temporary-files
         (mapcar
          (lambda (text) (let ((filename (make-temp-file "emacs.diff-registers.")))
                           (with-temp-file filename
                             (insert text))
                           filename))
          (list text1 text2))))
    ;; Call external diff as a subprocess.
    (condition-case nil
        (let ((args (append (list diff-executable nil nil nil) temporary-files)))
          (print args)
          (apply 'call-process args))
      (error nil))
    ;; Cleanup temporary files.
    (dolist (filename temporary-files)
      (when (file-exists-p filename) (delete-file filename))) ))

(defun diff-registers (command reg1 reg2)
  (interactive)
  (external-diff command (get-register reg1) (get-register reg2)))

(defun diff-kill-ring (command)
  (let* ((idx (if mark-active -1 0))
         (selections (list (current-kill (+ idx 1) t)
                           (if (= idx 0)
                               (current-kill idx t)
                             (buffer-substring (region-beginning) (region-end)))))
         (left (car selections))
         (right (cadr selections)))
    (external-diff command left right) ))



(defvar user-diff-command-primary "tmux-diff")
(defvar user-diff-command-secondary "xxdiff")

(defun user-diff-registers (reg1 reg2)
  (interactive "cRegister for left side:\ncRegister for right side:")
  (diff-registers (if current-prefix-arg
                      user-diff-command-secondary
                    user-diff-command-primary) reg1 reg2))

(defun user-diff-kill-ring ()
  (interactive)
  (diff-kill-ring (if current-prefix-arg
                      user-diff-command-secondary
                    user-diff-command-primary)))

(define-key* ctl-x-map [(_)] 'user-diff-kill-ring)
(define-key* ctl-x-r-map [(_)] 'user-diff-registers)



;;------------------------------------------------------------------------------
;; Mouse support.

(setq mouse-yank-at-point t)

;; Support for mouse wheels.
;;     ;;mouse-wheel-mode
;;  ;; The variables `mouse-wheel-follow-mouse' and `mouse-wheel-scroll-amount'
;;  ;; determine where and by how much buffers are scrolled.


(require 'mouse-drag) ;; Cool mouse dragging.
;; (require 'mouse-copy) ;; I don't like mouse-copy so much...

(setq mouse-buffer-menu-mode-mult 100)
(setq mouse-buffer-menu-maxlen 45)

;; mouse.el
(setq mouse-buffer-menu-mode-groups
      '(("\\*.*\\*" . "Special")
	("*" . "Normal")) )

;; Control + mouse
(global-set-key* [C-down-mouse-1] 'mouse-buffer-menu)
;; (global-set-key* [C-down-mouse-2] ;; reserved for related-files menu
(global-set-key* [C-down-mouse-3] 'mouse-drag-drag)

;; Shift + mouse
(global-set-key* [S-down-mouse-1] 'user-mouse-set-font)
(global-set-key* [S-down-mouse-2] 'mouse-major-mode-menu)
(global-set-key* [S-down-mouse-3] 'imenu)

;; Control + Shift + mouse
;; none.

;; Function override for the function that builds the menu, in order to 1)
;; left-justify the buffer file names (the - in format)
(defun mouse-buffer-menu-alist (buffers)
  (let (tail
	(maxlen 0)
	head)
    (setq buffers
	  (sort buffers
		(function (lambda (elt1 elt2)
			    (string< (buffer-name elt1)
				     (buffer-name elt2))))))
    (setq tail buffers)
    (while tail
      (or (eq ?\ (aref (buffer-name (car tail)) 0))
	  (setq maxlen
		(max maxlen
		     (length (buffer-name (car tail))))))
      (setq tail (cdr tail)))
    (setq tail buffers)
    (while tail
      (let ((elt (car tail)))
	(if (/= (aref (buffer-name elt) 0) ?\ )
	    (setq head
		  (cons
		   (cons
		    (format
		     (format "%%-%ds  %%s%%s  %%s" maxlen)
		     (buffer-name elt)
		     (if (buffer-modified-p elt) "*" " ")
		     (save-excursion
		       (set-buffer elt)
		       (if buffer-read-only "%" " "))
		     (or (buffer-file-name elt)
			 (save-excursion
			   (set-buffer elt)
			   (if list-buffers-directory
			       (expand-file-name
				list-buffers-directory)))
			 ""))
		    elt)
		   head))))
      (setq tail (cdr tail)))
    ;; Compensate for the reversal that the above loop does.
    (nreverse head)))


;; Mouse wheel support.
(global-set-key* [mouse-4] '(lambda () (interactive) (scroll-down 5)))
(global-set-key* [mouse-5] '(lambda () (interactive) (scroll-up 5)))
(global-set-key* [S-mouse-4] '(lambda () (interactive) (scroll-down 1)))
(global-set-key* [S-mouse-5] '(lambda () (interactive) (scroll-up 1)))
(global-set-key* [C-mouse-4] '(lambda () (interactive) (scroll-down)))
(global-set-key* [C-mouse-5] '(lambda () (interactive) (scroll-up)))



;;------------------------------------------------------------------------------
;; Smart completion.

;; FIXME: 2012-07-01 - replace this with kcomplete?
(require 'icomplete)
(icomplete-mode 1)


;;; (load "completion")
;;; (initialize-completions)
;;; need to run this as of 20.4 for `completion' (dynamic-completion-mode)

;; Ignored extensions
(mapc
 (lambda (x) (add-to-list 'completion-ignored-extensions x))
 '(".so" ".lo" ".42fasl" ".mfasl" ".class" ".dvi" ".class" ".pyc" ".pyo"))



;;------------------------------------------------------------------------------
;; Text properties.

(defun remove-text-properties-in-region (beg end)
  "Removes all text properties for characters in region."
  (interactive "r")
  (set-text-properties beg end nil))


;;------------------------------------------------------------------------------
;; repeat-last-character

;; This is already defined in restructuredtext.el
(if (not (fboundp 'repeat-last-character))

    (defun repeat-last-character (&optional tofill)
      "Fills the current line up to the length of the preceding line (if not
empty), using the last character on the current line.  If the preceding line is
empty, we use the fill-column.

If a prefix argument is provided, use the next line rather than the preceding
line.

If the current line is longer than the desired length, shave the characters off
the current line to fit the desired length.

As an added convenience, if the command is repeated immediately, the alternative
column is used (fill-column vs. end of previous/next line)."
      (interactive)
      (let* ((curcol (current-column))
             (curline (+ (count-lines (point-min) (point))
                         (if (eq curcol 0) 1 0)))
             (lbp (line-beginning-position))
             (prevcol (if (and (= curline 1) (not current-prefix-arg))
                          fill-column
                        (save-excursion
                          (forward-line (if current-prefix-arg 1 -1))
                          (end-of-line)
                          (skip-chars-backward " \t" lbp)
                          (let ((cc (current-column)))
                            (if (= cc 0) fill-column cc)))))
             (rightmost-column
              (cond (tofill fill-column)
                    ((equal last-command 'repeat-last-character)
                     (if (= curcol fill-column) prevcol fill-column))
                    (t (save-excursion
                         (if (or (= prevcol 0) (< prevcol curcol)) fill-column prevcol)))
                    ))
	     )
        (end-of-line)
	;; (message (current-column))
	;; (message (rightmost-column))
        (if (> (current-column) rightmost-column)
            ;; shave characters off the end
            (delete-region (- (point)
                              (- (current-column) rightmost-column))
                           (point))
          ;; fill with last characters
          (insert-char (preceding-char)
                       (- rightmost-column (current-column))))
        ))

)

(global-set-key* [(control meta =)] 'repeat-last-character)

(defmacro set-alternative-behaviour (target alternative)
  "Generic way to set an alternative behaviour on any function, via an advice."
  (if (eq target alternative)
      (error "Error: Cannot set the alternative to be the same function.")
    `(defadvice ,target (around
			 ,(make-symbol (concat (symbol-name target) "-alternative"))
			 activate)
       (if (and current-prefix-arg (listp current-prefix-arg))
	   (let ((current-prefix-arg nil))
	     (call-interactively ',alternative))
	 (if (called-interactively-p 'any)
	     (call-interactively (ad-get-orig-definition ',target)) ad-do-it) ))
    ))

(if (>= emacs-major-version 24)
    (set-alternative-behaviour count-words-region repeat-last-character)
    (set-alternative-behaviour count-lines-region repeat-last-character) )

(set-alternative-behaviour backward-kill-word backward-kill-sexp)

(define-key* ctl-x-map [(meta backspace)] 'backward-kill-capword)
(define-key* ctl-x-map [(?\M-\d)]         'backward-kill-capword)

(when (featurep 'repeatable)
  (repeatable-command-advice backward-kill-capword) )



;;------------------------------------------------------------------------------
;; Visit last killed buffer feature.

(defun kill-current-buffer ()
  "Kills the current buffer without asking and saves the file name for
last-killed-buffer."
  (interactive)
  (setq last-killed-buffer buffer-file-name)
  (kill-buffer (current-buffer)))

(global-set-key* [(control K)] '(lambda () (interactive) (message "Not supported.")))
(global-set-key* [(control meta k)] 'kill-current-buffer)
;; Doesn't work in a terminal:
;;(global-set-key* (kbd "<C-TAB>") 'my-func)
;;(global-set-key* [?\C-\t] 'my-func)



(defun find-file-last-killed-buffer ()
  "Edit last file that was buffer-killed (See last-killed-buffer)."
  (interactive)
  (find-file last-killed-buffer))

(defun delete-frame-and-buffer ()
  (interactive)
  (kill-current-buffer)
  (delete-frame))

;;------------------------------------------------------------------------------
;; Trailing whitespace.

(setq show-trailing-whitespace nil)

(defun toggle-show-trailing-whitespace ()
  (interactive)
  (setq show-trailing-whitespace (not show-trailing-whitespace))
  (redraw-display))
(global-set-key* [(control c)(control w)] 'toggle-show-trailing-whitespace)

(defadvice delete-trailing-whitespace (after add-message activate)
  (message "Trailing whitespace deleted."))

(global-set-key* [(control c)(control w)] 'toggle-show-trailing-whitespace)
(global-set-key* [(control c)(w)] 'delete-trailing-whitespace)





;;; Andreas Rhler
;;(defun fixup-whitespace ()
;;  "Fixup white space between objects around point.
;;Leave one space or none, according to the context."
;;  (interactive "*")
;;  (save-excursion
;;    ;; 2007-11-28 a.roehler@web.de changed section start
;;    (skip-chars-backward " \t\r\n\f")
;;    (set-mark (point))
;;    (skip-chars-forward " \t\r\n\f")
;;    (kill-region (point) (mark))
;;;;;     (delete-horizontal-space)
;;    ;; 2007-11-28 a.roehler@web.de changed section end
;;    (if (or (looking-at "^\\|\\s)")
;;            (save-excursion (forward-char -1)
;;                            (looking-at "$\\|\\s(\\|\\s'")))
;;        nil
;;      (insert ?\s))))


(defun setup-auto-delete-trailing-whitespace ()
  "Automatically setup for deleting trailing whitespace for all code
under my projects subdirectory."
  (when (and user-projects-root
             (string-match user-projects-root (buffer-file-name)))
    (setq show-trailing-whitespace t)
    (add-to-list 'write-contents-functions 'delete-trailing-whitespace)))

(add-hook 'find-file-hook 'setup-auto-delete-trailing-whitespace)


;;------------------------------------------------------------------------------
;; Deleting blank lines "more easily"

(defun delete-blank-lines-ext ()
  "Like delete-blank-lines, but on nonblank line, doesn't have to be the
immediatly following blank lines, could be first set of blank lines after the
following set of non-blank lines. This is more convenient for deleting many sets
of blank lines."
  (interactive)
  (let (didit)
    (save-excursion
      (beginning-of-line)
      (if (not (looking-at "[ \t]*$"))
          (progn
            (forward-line 1)
            (if (not (looking-at "[ \t]*$"))
                (progn
                  (delete-region
                   (re-search-forward "^[ \t]*$" nil t)
                   (if (re-search-forward "[^ \t\n]" nil t)
                       (progn (beginning-of-line) (point)) (point-max)))
                  (setq didit t)
                  )))))
    (if (not didit) (call-interactively 'delete-blank-lines))
    ))


(when (featurep 'repeatable)
  (substitute-key-definition
   'delete-blank-lines
   (lambda ()
     "Select between the repeating and single-shot call to be able
   to call open-line directly after when the initial region
   consists of open lines."
     (interactive)
     (call-interactively
      (if (save-excursion (beginning-of-line) (looking-at "^\\s-*$"))
	  'delete-blank-lines-ext
	(repeatable-command-def 'delete-blank-lines-ext))
      ))
   (current-global-map))
  )



;;------------------------------------------------------------------------------
;; Select/delete what's in between sexp.

(defun compute-enclosing-sexp-boundary ()
  "Returns a pair of points of the enclosing sexp boundaries, from the current
point."
  (let* ( (from (point))
          beg end tmp )

    ;; move by sexps until we hit the end of them
    (setq beg
          (condition-case nil
              (progn
                (setq tmp from)
                (while (setq tmp (scan-sexps tmp -1))))
            (error tmp)))

    (setq end
          (condition-case nil
              (progn
                (setq tmp from)
                (while (setq tmp (scan-sexps tmp 1))))
            (error tmp)))

    ;; move a little further to the separator, and then just inside.
    (save-excursion
      (goto-char beg)
      (setq beg (+ (re-search-backward "\\((\\|\\[\\|{\\)") 1))
      (goto-char end)
      (setq end (- (re-search-forward "\\()\\|\\]\\|}\\)") 1)) )

    (list beg end)))

(defadvice mark-sexp (around user-enclosing-sexp activate)
 "If invoked just with \\[universal-argument], mark enclosing sexp."
 (if (equal (ad-get-arg 0) '(4))
     (let* ((be (compute-enclosing-sexp-boundary)))
       (push-mark (car be) nil t)
       (goto-char (cadr be)))
   ad-do-it))

(global-set-key* [(control meta ?^)] 'mark-sexp)

;; In emacs-cvs you could do this:
;;  (global-set-key* [rempap mark-sexp] 'mark-sexp-with-enclosing-hotrod)
;; instead of this:
;;  (substitute-key-definition
;;   'mark-sexp-with-enclosing-hotrod 'mark-sexp (current-global-map))



;;------------------------------------------------------------------------------
;; Rectangles.

;; ** The new command M-x string-insert-rectangle is like `string-rectangle',
;; but inserts text instead of replacing it.


;;------------------------------------------------------------------------------
;; Numbered rectangles.

(defun number-rectangle (start end no)
  "Replace rectangle contents with a set of incrementing numbers on each line.
With prefix argument, query for starting number.

Called from a program, takes three args; START, END and STRING."
  (interactive "r\nnStarting number: ")
  (let ((number-rectangle-current no))
    (operate-on-rectangle 'number-rectangle-line start end t)))

(defun number-rectangle-line (startpos begextra endextra)
  (delete-region startpos (point))
  (insert (number-to-string number-rectangle-current))
  (setq number-rectangle-current (+ number-rectangle-current 1)))

(global-set-key* [(control x)(r)(p)] 'number-rectangle)




;;------------------------------------------------------------------------------
;; Ask before quitting.

(setq confirm-kill-emacs 'y-or-n-p)


  ;; Replaces save-buffers-kill-emacs.
  (defun default-exit-from-emacs (&optional arg)
    "Offer to save each buffer, then ask about killing this Emacs fork.
       With prefix arg, silently save all file-visiting buffers, then ask."
    (interactive "P")
    (save-some-buffers arg t)
    ;; (setq last-nonmenu-event nil) ;; For menu box
    (if (y-or-n-p "Really quit emacs? ")
	(kill-emacs)))

  (global-set-key* [(control x)(control c)] 'default-exit-from-emacs)


  (defadvice recenter (after user-recenter-refontify activate)
    "If recenter is invoked just with \\[universal-argument],
      re-fontify the buffer (if font-lock is enabled)."
    (when (and (equal current-prefix-arg '(4))
	       font-lock-mode)
      (font-lock-ensure)))


;;------------------------------------------------------------------------------
;; Convert tabs to spaces.

(defun untabify-buffer ()
  "Untabifies the whole buffer."
  (interactive)
  (untabify (point-min) (point-max)))

;;------------------------------------------------------------------------------
;; Functions to allow me to easily scavenge text around (a *very* common operation).

(defun insert-at-register (beg end register)
  "Insert the content of the region at the point stored in the given register."
  (interactive "rInsert at register: \nc")
  ;; (print beg)
  ;; (print end)
  ;; (print register)
  (jump-to-register register)
  (insert (buffer-substring beg end)) )

(define-key* ctl-x-r-map [?a] 'insert-at-register)


;;------------------------------------------------------------------------------
;; Compile using text from a register.

;; Give it its own buffer name.
(defun compile-register (register &optional arg)
  "Compile using the text from register REGISTER.  (REGISTER is a character.)"
  (interactive (progn
		 (list (register-read-with-preview "Compile register: ")
		       current-prefix-arg)))
  (let ((val (get-register register)))
    (cond
     ((stringp val)
      (let ((compilation-buffer-name-function
             (lambda (mode-name) (format "*command: %s*" val))))
        (compile val)))
     (t
      (error "Register does not contain text")))))

(defun show-compilation-buffer ()
  (interactive)
  (switch-to-buffer "*compilation*"))

(define-key* global-map [(control c)(r)] 'compile-register)
(define-key* global-map [(control c)(v)] 'compile-register)
(define-key* global-map [(control c)(b)] 'show-compilation-buffer)


;;------------------------------------------------------------------------------
;; Auto bookmarks.

;; (setq bookmark-name (event-basic-type last-input-event))

(defun bookmark-auto-set ( name )
  "Sets a bookmark at POINT and name it automatically by the
last-input-event."
  (interactive)
  (save-restriction
    (widen)
    (point-to-register 'name))
  (message "Bookmark %s set." name ))

(defun bookmark-auto-jump ( name )
  "Jumps to the bookmark named as in last-input-event."
  (interactive)
  (widen)
  (save-restriction
    (widen)
    (jump-to-register 'name))
  (message "Jumped to bookmark %s." name))


;;------------------------------------------------------------------------------
;; Automatically save window configuration to register on C-x 1; restore with C-x !

(defadvice delete-other-windows (before save-window-configuration activate)
  (unless (= (length (window-list)) 1)
    (window-configuration-to-register ?!)))

(define-key* ctl-x-map [(?!)]
  (lambda () (interactive) (jump-to-register ?!)))


;;------------------------------------------------------------------------------
;; split-string-with-caps

(defun split-string-with-caps (str)
  "Splits a character string into a list of substrings where caps are
delimiters.  Takes the string to split as input and returns the list of
substrings."
  (let ((word-list nil)
        (lastidx 0)
        (curidx 0)
        (case-fold-search nil))
    (while (progn
             (setq curidx (string-match "[A-Z]" str (+ 1 curidx)))
             (if curidx
                 (progn
                   (setq word-list
                         (append word-list
                                 (list (substring str lastidx curidx) )) )
                   (setq lastidx curidx)
                   )
               (progn
                 (setq word-list
                       (append word-list
                               (list (substring str lastidx) )))
                 nil)
               )))
    word-list))

;;------------------------------------------------------------------------------
;; capitalize-words that preserves caps within the word, if called with prefix
;; argument.

(defun capitalize-word-preserve ()
  (interactive)
  (if (listp current-prefix-arg)
      (let ((curpos (point))
            limit)
        (setq limit
              (search-forward-regexp
               "[A-Z]" (save-excursion (forward-word 1) (point))))
        (capitalize-region curpos limit)
        (goto-char curpos) (forward-word 1) )
    (call-interactively capitalize-word)))

(global-set-key* [(meta C)] 'capitalize-word-preserve)


;;------------------------------------------------------------------------------
;; Navigate caml-case words SuchAsThisOne

;; Note: cap-words.el is deprecated in favor of subword.el in emacs25.
(require 'subword)
(global-set-key* [(control c)(control h)]
		(lambda () (interactive) (call-interactively 'subword-mode))) ;; doesn't work


;;------------------------------------------------------------------------------
;; load-file-list-in-buffer

(defun load-file-list-in-buffer (buffer)
  "Loads in files whose names are specified in a buffer"
  (interactive "bBuffer: ")
  (save-excursion
    (switch-to-buffer buffer)
    (let ((beg nil)
          (end nil)
          (bufend (point-max))
          (lin nil))
      (beginning-of-buffer)
      (while (not (equal (point) bufend))
        (setq lin (thing-at-point 'line))
        (find-file-noselect (substring lin 0 (- (length lin) 1)))
        (forward-line 1)
        ))))


;;------------------------------------------------------------------------------
;; Go fetch some text to paste.

(defvar excursion-markers nil
  "A stack of markers to come back to.")

(defun excursion-push-mark ()
  "Push point on the mark stack."
  (interactive)
  (message "Point saved.")
  (push (point-marker) excursion-markers))

(defun excursion-pop-mark ()
  "Pop the mark stack and move the cursor there."
  (interactive)
  (unless excursion-markers
    (error "Excursion markers list empty!"))
  (let ((m (pop excursion-markers)))
    (switch-to-buffer (marker-buffer m))
    (goto-char (marker-position m))
    (unless excursion-markers
      (push m excursion-markers))
    ))

(defun excursion-pop-and-yank ()
  "If the current region is active, save it to the kill-ring, pop
the mark top, and yank it at the destination."
  (interactive)
  (when mark-active
    (kill-ring-save (region-beginning) (region-end)))
  (excursion-pop-mark)
  (yank))

;; Note: this is confusing, breaks the context principle of the humane
;; interface.
(defun excursion-mark-or-yank ()
  "If there is no region, push the current marker on the stack.
Otherwise, pop the mark and yank the contents of the region."
  (interactive)
  (if mark-active
      (excursion-pop-and-yank)
    (excursion-pop-mark)))

(when nil ;; Disabled for now, I don't seem to use it
  (global-set-key* [(control c)(control \ )] 'excursion-push-mark)
  (global-set-key* [(control c)(control j)] 'excursion-pop-mark)
  (global-set-key* [(control c)(j)] 'excursion-pop-mark)
  (global-set-key* [(control c)(control y)] 'excursion-pop-and-yank)
  (global-set-key* [(control c)(\ )] 'excursion-mark-or-yank)
  )

;;------------------------------------------------------------------------------
;; find-alternate file by following symlink.

(defun revert-file-follow-symlink (&optional file-truename-func silent)
  "find-alternate file by following symlink."
  (interactive)
  (let ((real-name (funcall (or file-truename-func 'file-truename)
                            buffer-file-name)))
    (if (not (equal real-name buffer-file-name))
        (progn
          (if (not silent)
              (message (concat "Following link(s) to " real-name)))
          (kill-buffer (current-buffer))
          (find-file real-name))
      (if (not silent)
          (message "Nothing to revert, file is not a symlink.")))
    ))

(global-set-key* [(control c)(control v)] 'revert-file-follow-symlink)


;;------------------------------------------------------------------------------
;; make-buffer-command.

(defun make-buffer-command ()
  "Creates a new *scratch* buffer and makes it current."
  (interactive)
  (switch-to-buffer (generate-new-buffer "*scratch*")))

(define-key* ctl-x-5-map "5" 'make-buffer-command)


;;------------------------------------------------------------------------------
;; smarter selection in minibuffer queries

(defvar user-switch-buffer-command 'ido)

(cond
 ((eq user-switch-buffer-command 'ido)
  (require 'ido)
  (ido-mode t)

  ;; Ignore case by default.
  (setq ido-case-fold t)

  ;; Disable auto-merge, it's #&$*&$% annoying
  (setq ido-auto-merge-delay-time 3600)

  ;; Don't bother double-checking when I open a new file, I'm not a child.
  (setq ido-create-new-buffer 'always)

  ;; Enable this for fuzzy matching.
  (setq ido-enable-flex-matching t)

  ;; Make it possible to complete on quite large directories.
  (setq ido-max-directory-size 100000)

  ;; Create a function to be able to access the imenu using ido.
  ;; Copied from https://gist.github.com/2360578
  (defun ido-imenu ()
    "Update the imenu index and then use ido to select a symbol to navigate to.
Symbols matching the text at point are put first in the completion list."
    (interactive)
    (imenu--make-index-alist)
    (let ((name-and-pos '())
          (symbol-names '()))
      (cl-flet ((addsymbols (symbol-list)
                            (when (listp symbol-list)
                              (dolist (symbol symbol-list)
                                (let ((name nil) (position nil))
                                  (cond
                                   ((and (listp symbol) (imenu--subalist-p symbol))
                                    (addsymbols symbol))

                                   ((listp symbol)
                                    (setq name (car symbol))
                                    (setq position (cdr symbol)))

                                   ((stringp symbol)
                                    (setq name symbol)
                                    (setq position (get-text-property 1 'org-imenu-marker symbol))))

                                  (unless (or (null position) (null name))
                                    (add-to-list 'symbol-names name)
                                    (add-to-list 'name-and-pos (cons name position))))))))
        (addsymbols imenu--index-alist))
      ;; If there are matching symbols at point, put them at the beginning of `symbol-names'.
      (let ((symbol-at-point (thing-at-point 'symbol)))
        (when symbol-at-point
          (let* ((regexp (concat (regexp-quote symbol-at-point) "$"))
                 (matching-symbols (delq nil (mapcar (lambda (symbol)
                                                       (if (string-match regexp symbol) symbol))
                                                     symbol-names))))
            (when matching-symbols
              (sort matching-symbols (lambda (a b) (> (length a) (length b))))
              (mapc (lambda (symbol) (setq symbol-names (cons symbol (delete symbol symbol-names))))
                    matching-symbols)))))
      (let* ((selected-symbol (ido-completing-read "Symbol? " symbol-names))
             (position (cdr (assoc selected-symbol name-and-pos))))
        (goto-char position))))

  (defadvice ido-imenu (before push-mark activate)
    "Push the mark before moving to it."
    (push-mark))

  ;;(define-key* ctl-x-map [(control h)] 'ido-imenu)

  (when (require 'ido-vertical-mode nil t)
    (ido-vertical-mode 1) )


  ;; Create an ido function/binding that will lookup the filecache.
  (require 'filecache)
  (defun ido-find-filecache (file)
    "Using ido, interactively open file from file cache'.
First select a file, matched using ido-switch-buffer against the contents
in `file-cache-alist'. If the file exist in more than one
directory, select directory. Lastly the file is opened."
    (interactive (list (ido-read-filecache "Filecache: "
					    (mapcar
					     (lambda (x)
					       (car x))
					     file-cache-alist))))
    (let* ((record (assoc file file-cache-alist)))
      (find-file
       (expand-file-name
	file
	(if (= (length record) 2)
	    (car (cdr record))
	  (ido-read-filecache
	   (format "Find %s in dir: " file) (cdr record)))))))

  (defun ido-read-filecache (prompt choices)
    (let ((ido-make-buffer-list-hook
	   (lambda ()
	     (setq ido-temp-list choices))))
      (ido-read-buffer prompt)))

  (define-key* ctl-x-map [(control g)] 'ido-find-filecache)
  (define-key* ctl-x-map [(control h)] 'find-file-at-point)

  ;; Use same binding as top-level to go to switch buffer.
  (define-key ido-common-completion-map "\C-xb" 'ido-enter-switch-buffer)

  ;; Make C-xC-g switch to filecache input when in ido-find-file/ido-switch-buffer
;; FIXME: TODO, make this work, unfinished
;;   (define-key ido-common-completion-map "\C-xg" 'ido-enter-switch-filecache)
;;   (defun ido-enter-switch-filecache ()
;;     "Drop into `ido-switch-buffer' from file switching."
;;     (interactive)
;;     (message "TESSSS")
;; ;;    (setq ido-exit 'find-file) ;; somehow exits
;;     (setq ido-exit 'pop)
;; ;;    (call-interactively 'ido-find-filecache)
;;     (exit-minibuffer)
;;     )



;; (when ido-context-switch-command
;;   (define-key map "\C-xb" ido-context-switch-command))

;; (define-key* ido-file-dir-completion-map "M-i"
;;   (lambda () (interactive) (message "TEST")))

;; (define-key ido-common-completion-map "M-i"
;;   (lambda () (interactive) (message "TEST")))



;; (defun min-file-cache-ido-find-file ()
;;   "Open a file from the file cache.
;; First select a file from `file-cache-alist'.  If the file exist
;; in more than one directory one is asked to select which to open.
;; If you find out that the desired file is not present in the file
;; cache then you may want to fallback to normal ido find file with
;; C-f.
;; Bind this command to C-x C-f to get:
;;
;;  C-x C-f         -> Open file in filecache.
;;  C-x C-f C-f     -> Open file with normal ido.
;;  C-x C-f C-f C-f -> Open file with vanilla find-file.
;; "
;;   (interactive)
;;   (let* (jcl-ido-text
;;          (file (let ((ido-setup-hook (cons (lambda ()
;;                                              (define-key ido-completion-map [(control ?f)]
;;                                                (lambda (arg)
;;                                                  (interactive "P")
;;                                                  (if jcl-ido-text
;;                                                      (ido-magic-forward-char arg)
;;                                                    (setq jcl-ido-text ido-text
;;                                                          ido-text 'fallback-from-cache
;;                                                          ido-exit 'done)
;;                                                    (exit-minibuffer)))))
;;                                            ido-setup-hook)))
;;                  (ido-completing-read "Cached File: "
;;                                       (mapcar 'car file-cache-alist)))))
;;     (if (eq file 'fallback-from-cache)
;;         (progn
;;           (setq minibuffer-history (delete 'fallback-from-cache minibuffer-history))
;;           (ido-file-internal ido-default-file-method
;;                              nil
;;                              nil
;;                              "Ido Find File: "
;;                              nil
;;                              jcl-ido-text))
;;       (let ((record (assoc file file-cache-alist)))
;;         (find-file
;;          (expand-file-name
;;           file
;;           (if (= (length record) 2)
;;               (cadr record)
;;             (ido-completing-read (format "Find %s in dir: " file)
;;                                  (cdr record)
;;                                  nil
;;                                  t))))))))
;;

;; Example using ido with an external process:
;; http://puntoblogspot.blogspot.no/2012/12/using-ido-completing-read-to-get-input.html
;;
;;  (defun radio ()
;;    (interactive)
;;    (let ((filename
;;          (ido-completing-read "which radio?: "
;;                               (directory-files
;;                                "/home/rgrau/bin/radios/"
;;                                nil
;;                                "\\.pls$\\|\\.asx$"))))
;;      (async-shell-command
;;       (concat "mplayer -playlist /home/rgrau/bin/radios/" filename) "*mplayer*" )
;;      (message "choosen: %s" filename)))

  )

 ((eq user-switch-buffer-command 'iswitchb)
  (require 'iswitchb)
  (if (>= emacs-major-version 24)
      (iswitchb-mode)
    (iswitchb-default-keybindings))

  ;;(setq iswitchb-regexp 't)
  (setq iswitchb-case 't)

  ;; Ignore special buffers
  ;;
  ;; Used to be: (setq iswitchb-buffer-ignore '("^\\*" "^ "))
  (require 'cl-lib)
  (defun iswitchb-ignore-some-special-bufs (name)
    "Ignore the temporary buffers except the gud buffers."
    (save-excursion
      (if (not (some (lambda (x) (string-match x name))
		     '("\*gud-"
		       "\*Shell Command Output\*"
		       "\*compilation\*"
		       "\*Messages\*"
		       "\*scratch.*\*"
		       "\*shell\*"
		       "\*slime.*\*"
		       "\*.*repl.*\*"
		       ".*cl-connection.*"
		       "\*R*\*"
		       )))
	  (string-match "^\\*" name))))
  (setq iswitchb-buffer-ignore '(iswitchb-ignore-some-special-bufs ;;"^ "
				 ))


  ;; Move them to the end
  (defun iswitchb-move-special-buffers-to-end ()
    "Move the special buffers to the end of the list."
    (let ((special (delq nil (mapcar
			      (lambda (x)
				(if (or
				     (string-match "\*$" x))
				    x))
			      iswitchb-temp-buflist))))
      (iswitchb-to-end special)))

  (add-hook 'iswitchb-make-buflist-hook
	    'iswitchb-move-special-buffers-to-end)

  ;; Add a key to toggle showing all the buffers
  (add-hook 'iswitchb-define-mode-map-hook
	    (lambda ()
	      (define-key* iswitchb-mode-map "\C-v" 'iswitchb-toggle-ignore)))

  ;; Make sure we're not ignoring when invoking iswitchb.
  (add-hook 'iswitchb-minibuffer-setup-hook
	    (lambda () (if (and (null iswitchb-buffer-ignore)
				iswitchb-buffer-ignore-orig)
			   (iswitchb-toggle-ignore))))

  ))



;;------------------------------------------------------------------------------
;; file-cache / filecache setup.

(setq file-cache-completion-ignore-case t)

(defvar file-cache-init-hook nil
  "Hooks for initializing the file cache. This is meant to be added to for customization.")

;; Press C-TAB to in minibuffer prompt to activate file-cache completion.
(defun file-cache-initialize ()
  (interactive)
  (message "Loading file cache...")

  ;;; ;; Make sure the filecache binding works even when C-i is eaten up by the
  ;;; ;; terminal. (C-TAB cannot be received by a terminal.)
  ;;; (define-key* minibuffer-local-map [(meta i)] 'file-cache-minibuffer-complete)
  ;;; (define-key* minibuffer-local-map [(control z)] 'file-cache-minibuffer-complete)

  ;; Run all the registered hooks.
  (run-hooks 'file-cache-init-hook)

  (message "Done.")
  )

(defun file-cache-reset ()
  "Clear the file-cache and rerun the initialization, including the hooks.
This is useful when the files change and you want to refresh your file-cache."
  (interactive)
  (file-cache-clear-cache)
  (file-cache-initialize))

;;; Note: removed on 2016-01-03 to avoid loading file-cache twice. There's an
;;; explicit call later on that loads the filecache later, after processing all
;;; the project files.
;;;
;; Automatically initialize a lot of directories that we're interested in after
;; load.
;(eval-after-load "filecache" '(file-cache-initialize))

(defun add-found-file-to-file-cache ()
  "Memorize in the file cache all the files loaded via find-file."
  (let ((fn (buffer-file-name)))
    (when (file-exists-p fn) ;; Just to avoid the annoying message.
      (file-cache-add-file fn))
    ))
(add-hook 'find-file-hook 'add-found-file-to-file-cache)


;;
;; Useful functions for implementing filecache hooks.
;;

(defun directory-files-recursive (root match)
  (let ((max-lisp-eval-depth 10000))
    (let ((files (filter 'file-regular-p (directory-files root t match)))
          (dirs (filter
                 (lambda (x) (and (file-directory-p x)
                                  (not (file-symlink-p x))
                                  (not (member (file-name-nondirectory x)
                                               '("." "..")))))
                 (directory-files root t))))
      (append files
              (apply 'append (mapcar
                              (lambda (x) (directory-files-recursive x match))
                              (filter (lambda (x) (not (file-symlink-p x)))
                                      dirs))))
      )))


(defun walk-tree (root dir-function)
  "Walk through all the directories under root and call
DIR-FUNCTION for each directory, with three arguments:  the full
directory path, a list of subdirectories, and a list of filenames
contains in the directory. If DIR-FUNCTION returns nil, we
recurse through all the directories; if it returns 't, we skip
the children, and otherwise it may return a filtered version of
the directories list to recurse into."
  (let* ((dirfiles (directory-files root t))
         (dirs (mapcar 'file-name-nondirectory
                       (filter 'file-directory-p dirfiles)))
         (files (mapcar 'file-name-nondirectory
                        (filter (lambda (x) (not (file-directory-p x))) dirfiles)))
         (dirs (filter (lambda (x) (and (not (string= x ".")) (not (string= x "..")))) dirs))
         )
    (let ((subdirs (or (funcall dir-function root dirs files) dirs)))
      (dolist (dir (cond ((eq subdirs nil) dirs)
                         ((eq subdirs t) nil)
                         ('t subdirs)))
        (walk-tree (concat root "/" dir) dir-function)))))


(defun is-emacs-temp-file (fn)
  (string-match "^\.#" (file-name-nondirectory fn)))

(defun file-cache-add-by-regexp (croot regexp)
  "Add files from a hierarchy to the filecache."
  (when (and (file-exists-p croot)
             (file-directory-p croot) )
    (walk-tree croot
               (lambda (root dirs files)
                 (dolist (file files)
                   (when (and (not (is-emacs-temp-file file))
                              (string-match regexp file))
                     (file-cache-add-file (concat root "/" file))))
                 (filter (lambda (x)
                           (and (not (string-match (regexp-opt ignore-dirs) x))
                                (not (file-symlink-p x))))
                         dirs) ))
    ))


(defun file-cache-add-directory-files (dir)
  "Add files from a single directory (do not recurse)."
  (dolist (fn (directory-files dir t))
    (file-cache-add-file fn)))

(defun file-cache-add-relative-file (root filename)
  "Add a file relative to a root directory, if it exists."
  (let ((fn (concat root "/" filename)))
    (when (file-exists-p fn)
      (file-cache-add-file fn))))

(defun file-cache-c++-stl ()
  "STL files, by directory (we don't want the java ones, so we select explicitly)."
  (when most-recent-stl-dir
    (dolist (d (list
		most-recent-stl-dir
		(concat most-recent-stl-dir "/bits")
		(concat most-recent-stl-dir "/ext")
		(concat most-recent-stl-dir "/tr1")
		(concat most-recent-stl-dir "/backward")
		(concat most-recent-stl-dir "/debug")
		(concat most-recent-stl-dir "/x86_64-redhat-linux/bits")
		))
      (when (file-exists-p d)
	(file-cache-add-directory-files d)))))

(defun file-cache-global ()
  "The global file cache initialization."

  ;; Oft-edited configuration files.
  (dolist (x '("conf/etc/emacsrc"
	       "conf/etc/hgrc"
	       ))
    (when user-projects-root
      (file-cache-add-relative-file user-projects-root x)))

  (file-cache-c++-stl)

  (when user-projects-root

    ;; Add personal Elisp project sources.
    (file-cache-add-by-regexp (concat user-projects-root "/conf/lib/elisp" ) ".*\\.el$")

    ;; Add personal Python project sources.
    (file-cache-add-by-regexp (concat user-projects-root "/conf/lib/python" ) ".*\\.py$")

    ;; Add some of my personal text files.
    (file-cache-add-by-regexp (concat user-projects-root "/priv" ) ".*\\.\\(txt\\|asc\\)$")
    (file-cache-add-by-regexp (concat user-projects-root "/languages/lang" ) ".*\\.\\(txt\\|asc\\)$")
    ))

(add-hook 'file-cache-init-hook 'file-cache-global)









;; From Mathias Dahl / comp.emacs.sources
;;
;; (defun file-cache-iswitchb-file ()
;;   "Using iswitchb, interactively open file from file cache'.
;; First select a file, matched using iswitchb against the contents
;; in `file-cache-alist'. If the file exist in more than one
;; directory, select directory. Lastly the file is opened."
;;   (interactive)
;;   (let* ((file (file-cache-iswitchb-read "File: "
;;                                    (mapcar
;;                                     (lambda (x)
;;                                       (car x))
;;                                     file-cache-alist)))
;;          (record (assoc file file-cache-alist)))
;;     (find-file
;;      (concat
;;       (if (= (length record) 2)
;;           (car (cdr record))
;;         (file-cache-iswitchb-read
;;          (format "Find %s in dir: " file) (cdr record))) file))))
;; (defun file-cache-iswitchb-read (prompt choices)
;;   (let ((iswitchb-make-buflist-hook
;;       (lambda ()
;;         (setq iswitchb-temp-buflist choices))))
;;     (iswitchb-read-buffer prompt)))
;; (global-set-key* "\C-cf" 'file-cache-iswitchb-file)


;;------------------------------------------------------------------------------
;; C/C++ debugger within emacs

(require 'gud)
(setq gud-dbx-history t)

(when (featurep 'repeatable)
  (repeatable-command-advice gud-up)
  (repeatable-command-advice gud-down)
  (repeatable-command-advice gud-next)
  (repeatable-command-advice gud-step)
  (repeatable-command-advice gud-finish) )


(defun switch-to-first-gud-buffer ()
  (interactive)
  (switch-to-buffer
   (car (filter (lambda (x) (string-match "\\*gud-.*" (buffer-name x)))
		(buffer-list)))))

(global-set-key* (kbd "C-c C-z") 'switch-to-first-gud-buffer)

;; Note: how come we have two here?

(global-set-key* [(control x)(control z)]
		(lambda () (interactive)
		  (switch-to-buffer gud-comint-buffer)))


(defadvice gud-break (around gud-break-toggle activate)
  "Make gud-break a toggle function."
  (if current-prefix-arg
      (call-interactively 'gud-remove)
    ad-do-it))

(setq gdb-command-name "gdb --fullname --ex run --args ")

;; For the new debugging mode, use multiple window layout
(setq gdb-many-windows t)



;;------------------------------------------------------------------------------
;; imenu

(require 'imenu)

;; (autoload 'imenu-add-to-menubar "imenu" "Add imenu menu to menubar." nil)
;;(imenu-add-to-menubar "Index") can't add right now because no
;;current-local-map is created...
(setq imenu-always-use-completion-buffer-p nil)

(setq imenu-max-items 50)

(defun imenu-goto-function-top (name position &optional rest)
  "Imenu's original goto function except we want to align the function
with the top of the buffer window."
  (interactive)
  (imenu-default-goto-function name position rest)
  (recenter-top))

(setq-default imenu-default-goto-function 'imenu-goto-function-top)


;;------------------------------------------------------------------------------
;; Decompression.

(require 'jka-compr);; --- jka-compression (for zipped files)

;; Xournal files are gzipped. It's nice to be able to edit the background filename.
;; This doesn't appear to work: (add-to-list 'jka-compr-load-suffixes ".xoj")

;;(require 'arc-mode) ;;  Arc Lzh Zip Zoo format files


;;------------------------------------------------------------------------------
;; ange-ftp

;; (require 'ange-ftp)
;; (setq ange-ftp-default-user "anonymous")
;; (setq ange-ftp-generate-anonymous-password t)
;; (setq ange-ftp-default-password "anonymous@anonymous.org")

;;------------------------------------------------------------------------------
;; tramp

(if nil
    (progn
      (require 'tramp)
      ;; (require 'tramp-ftp)

      (add-to-list 'tramp-methods
      (setq tramp-methods
            (list

                   '("dlssh"
                     (tramp-login-program "C:/Cygwin/bin/ssh.exe")
                     (tramp-copy-program nil)
                     (tramp-remote-sh "/bin/sh")
                     (tramp-login-args
                      (("%h")
                       ("-l" "%u")
                       ("-p" "%p")
                       ("-e" "none" "-t" "-t" "/bin/sh")))
                     (tramp-copy-args nil)
                     (tramp-copy-keep-date-arg nil)
                     (tramp-password-end-of-line nil))
                   )
        (setq tramp-debug-buffer "tramp/debug")
        (setq tramp-verbose 10)
      ))
      ))


;;------------------------------------------------------------------------------
;; webdav

;; (require 'eldav)


;; --- documentation help ------------------------------------------------------

(require 'eldoc)
(autoload 'describe "describe" "describes just any elisp object" t)

(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)

;;------------------------------------------------------------------------------
;; For unique buffer names.

(require 'uniquify)

;;------------------------------------------------------------------------------
;; Write executables with correct protections.

;; From monnier.
(defun write-exec-hook ()
  "See if the file is a script and make it executable if it is."
  (save-excursion
    (goto-char (point-min))
    (if (looking-at "#!")
	(let ((modes (file-modes buffer-file-name)))
	  ;; We need to check for modes b/c of tramp, which does not provide the
	  ;; info when editing a remote file.
	  (when modes
	    (set-file-modes buffer-file-name
			    (logior modes 73))))))
  nil)

(add-hook 'after-save-hook 'write-exec-hook)


;;------------------------------------------------------------------------------
;; Page mode/narrow/widen

;;; No need for page-mode anymore, just use the default commands
;;; C-x n p and C-x n w to narrow or widen
;;; C-x [ and C-x ] to move between pages

(defun narrowedp ()
  (let ((nbeg (point-min))
        (nend (point-max)))
    (save-restriction
      (widen)
      (or (not (equal nbeg (point-min)))
          (not (equal nend (point-max)))) )))

(defun forward-page-narrowed ()
  (interactive)
  (if (narrowedp)
      (progn
        (widen)
        (forward-page)
        (narrow-to-page))
    (forward-page)))

(defun backward-page-narrowed ()
  (interactive)
  (if (narrowedp)
      (progn
        (if (equal (point) (point-min))
            (progn
              (widen)
              (if (>= (point) (+ (point-min) 2))
                  (backward-char 2))) ;; Skip delimiter
          (widen))
        (backward-page)
        (narrow-to-page))
    (backward-page)))


;;; Supersede default bindings by my own versions which widen+narrow if in
;;; narrow mode.
(global-set-key* [(control x)(n)(l)]
		'narrow-to-page)

(global-set-key* [(control x)(meta p)] 'backward-page-narrowed)
(global-set-key* [(control x)(meta n)] 'forward-page-narrowed)

(when (featurep 'repeatable)
  (repeatable-command-advice backward-page-narrowed)
  (repeatable-command-advice forward-page-narrowed) )


;;------------------------------------------------------------------------------
;; info mode

;; Remove clone-buffer that was added in emacs-21.
(require 'info)
(if (lookup-key Info-mode-map [(meta n)])
    (define-key* Info-mode-map [(meta n)] nil))


;;------------------------------------------------------------------------------
;; lex/flex/yacc/bison

;;(require 'bison-mode)



;;------------------------------------------------------------------------------
;; lisp-interaction-mode and emacs-lisp-mode

;;; pretty-printing elisp
;;;(require 'pp) seems to be standard now.
;;;(require 'cl-extra) ? didn't try.

(defun pretty-lisp-editing-hook ()
  (local-set-key* [(control x) (control e)] 'pp-eval-last-sexp) )

(add-hook 'lisp-interaction-mode-hook 'pretty-lisp-editing-hook)

;; FIXME: this was getting invoked on every invoke of C-x C-e, not sure why.
;;(add-hook 'emacs-lisp-mode-hook 'pretty-lisp-editing-hook)

;;------------------------------------------------------------------------------
;; elisp debugging

;; (require 'edebug)

;;------------------------------------------------------------------------------
;; perl-mode


;;------------------------------------------------------------------------------
;; tex-mode / latex-mode / bibtex-mode

;; Override default which goes into tex-mode.
(add-to-list 'auto-mode-alist '("\\.tex$" . latex-mode))

(setq latex-run-command "pdflatex")
;;(setq tex-command "pdftex")

(add-hook 'latex-mode-hook
          '(lambda ()
             (auto-fill-mode t)
             (setq paragraph-start
                   (concat paragraph-start "\\|\\\\dditem\\>"))

             ;; Override by the same bindings used in our xml mode, it is too
             ;; confusing otherwise.
             (local-set-key* [(control c)(control f)] 'latex-close-block)

             ;;(local-set-key* [(control c)(control ?9)] 'tex-compile)
             (local-set-key* [(control c)(b)] 'latex-block-bf)
             (local-set-key* [(control c)(i)] 'latex-block-it)
             (local-set-key* [(control c)(t)] 'latex-block-tt)
             (local-set-key* [(control c)(r)] 'latex-block-rm)
             (local-set-key* [(control c)(e)] 'latex-block-emph)
             (local-set-key* [(control c)(v)] 'latex-block-verb)
             ))

(defun latex-block-bf (beg end)
  (interactive "r")
  (insert-do-block beg end "\\textbf{" "}"))

(defun latex-block-it (beg end)
  (interactive "r")
  (insert-do-block beg end "\\textit{" "}"))

(defun latex-block-tt (beg end)
  (interactive "r")
  (insert-do-block beg end "\\texttt{" "}"))

(defun latex-block-rm (beg end)
  (interactive "r")
  (insert-do-block beg end "\\textrm{" "}"))

(defun latex-block-emph (beg end)
  (interactive "r")
  (insert-do-block beg end "\\emph{" "}"))

(defun latex-block-verb (beg end)
  (interactive "r")
  (insert-do-block beg end "\\verb@" "@"))

(defun insert-do-block (beg end blockbeg blockend)
  "Insert some text before and after the region,
or after point if the region is not active, bringing the cursor
in between the newly inserted text."
  (interactive "r")
  (let ((beg (or (and mark-active (region-beginning)) (point)))
        (end (or (and mark-active (region-end)) (point)))
        after-ins)
    (setq after-ins
          (save-excursion
            (goto-char end) (insert blockend)
            (goto-char beg) (insert blockbeg)
            (point)
            ))
    (when (= (- end beg) 0)
      (goto-char after-ins))
    ))



;;------------------------------------------------------------------------------
;; latex-beamer

(require 'tex-mode)

(define-abbrev latex-mode-abbrev-table "fr"
"%-----------------------------------------------------------------------------
\\begin{frame}[fragile]
  \\frametitle{}
  \\framesubtitle{}

\\end{frame}
" nil)



;;------------------------------------------------------------------------------
;; Cool stuff to check out when switching to emacs-21
;; delim-col.el
;; elide-head.el
;; emacs-lisp/re-builder.el
;; find-lisp.el instead of igrep.el
;; hi-lock.el  bof
;; minibuf-eldef.el
;; newcomment.el (stefan)
;; pcomplete.el (programmable completion!)
;; recentf.el
;; whitespace.el

;;------------------------------------------------------------------------------
;; subtle sub-word killing function to bind on shift del

(defun backward-kill-capword ()
  "Backward kill word, but if the previous word is a CapWord,
rubout only the last word in the capword."
  (interactive)
  (let ((orig (point))
        (case-fold-search nil))
    (if (save-excursion
          (backward-word 1)
          (let ((w (thing-at-point 'word)))
            (string-match "^[a-zA-Z0-9_]*[A-Z_][a-zA-Z0-9_]*$"
                          (buffer-substring (point) orig))))
        (progn
          (when (= (char-before) ?_)
            (backward-char 1))
          (when (re-search-backward "[^A-Z]\\([A-Z_]+[a-z0-9_]*\\|\\b[A-Za-z0-9_]+\\)" nil t)
            (goto-char (match-beginning 1))
            (when (= (char-after (match-beginning 1)) ?_)
              (forward-char 1))
            (delete-region (point) orig))
          )
      (backward-kill-word 1))
    ))


;;------------------------------------------------------------------------------
;; hack to convert mozilla's selection when pasting in.

(defun user-mouse-yank-at-click (click arg)
  (interactive "e\nP")
  (let ((sel (x-cut-buffer-or-selection-value)
             ;;(x-get-selection 'PRIMARY 'UTF8_STRING)
             )
        decoded)
    (when sel
      (setq decoded (decode-coding-string sel 'utf-8))
      (if decoded
          (x-set-selection 'PRIMARY decoded)))
    (mouse-yank-at-click click arg)
    ))

(defun user-yank-decode-unicode ()
  (interactive)
  (let ((sel ;;(x-cut-buffer-or-selection-value)
             (x-get-selection 'PRIMARY 'UTF8_STRING)
             )
        decoded)
    (if sel
        (setq decoded (decode-coding-string sel 'utf-8)) )
    (insert decoded)
    ))

;;(substitute-key-definition
;; 'mouse-yank-at-click 'user-mouse-yank-at-click
;; (current-global-map))

;; (add-to-list 'selection-converter-alist
;;    '(UTF8_STRING . xselect-convert-to-string))


;;------------------------------------------------------------------------------
;; Storing the selection in the kill-ring if it's not ours on any cut command.
;;
;; This is really useful if you need to do some work in the buffer before
;; pasting something from another application.  For example, I often select
;; something in a web browser or email application, then I have to open a file,
;; which implies I might do some deletes in the course of selecting the filename
;; to load, or other edit operations before pasting the text.  I would normally
;; lose my X selection when doing those cut operations, since emacs replaces the
;; X selection at that moment with his own.
;;
;; This stores the X selection in the kill-ring before you change it, if it is
;; set.

;; Monkey-patching.
(defadvice kill-new (before auto-paste-to-kill-ring activate)
  (let ((paste (and interprogram-paste-function
                    (funcall interprogram-paste-function))))
    ;; Note: some of this inspired from current-kill.
    (when paste
      (let ((interprogram-cut-function nil)
            (interprogram-paste-function nil))
        (kill-new paste)
        ))))

;;      ;; Also set register 'x' with this value for direct access.
;;      ;; This is optional.
;;      (set-register ?x paste)


;; Old crappy version (works):
;;
;;; Save the original x-select-text definition
;;(fset 'x-select-text-orig
;;      (symbol-function 'x-select-text))
;;
;;(defun x-select-text (text &optional push)
;;  "My own definition of x-set-cut-buffer which first save the
;;  selection to the kill-ring if the X selection belongs to another app."
;;  ;; Note: some of this picked straight off current-kill
;;  ;;
;;  ;; This goo gets called from kill-new, to replace the X selection.  Since this
;;  ;; is what we want to avoid ultimately, this is a good place to intercept.
;;  (let ((interprogram-paste (and interprogram-paste-function
;;                               (funcall interprogram-paste-function))))
;;    (if interprogram-paste
;;      (progn
;;        ;; Disable the interprogram cut function when we add the new
;;        ;; text to the kill ring, so Emacs doesn't try to own the
;;        ;; selection, with identical text.
;;        (let ((interprogram-cut-function nil))
;;          ;; At the point where we're getting called, the cut text has already
;;          ;; been put in the kill ring.  We must therefore insert the X
;;          ;; selection text after the head of the kill ring.
;;          (setcdr kill-ring (cons interprogram-paste (cdr kill-ring))))
;;        )))
;;
;;  ;; Reset the X selection here.
;;  (x-select-text-orig text push)
;;  )


;;-----------------------------------------------------------------------------
;; Selection to i-search

(defun search-selection ()
  "search for selected text"
  (interactive)
  (unless (use-region-p)
    (mark-word))
  (let ((beg (region-beginning))
        (end (region-end)))
    (kill-ring-save beg end)
    (goto-char beg)
    (isearch-mode t nil nil nil)
    (isearch-yank-kill) ))

(define-key search-map [(control w)] 'search-selection)


;;------------------------------------------------------------------------------
;; spell (aspell, ispell)

(setq-default ispell-program-name "aspell")

(setq flyspell-auto-correct-word t)
(setq flyspell-auto-correct-previous-word t)


;; use flyspell-mode for on-the-fly corrections

;;------------------------------------------------------------------------------
;; writegood-mode : http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/

;;(require 'writegood-mode)
;;(global-set-key* "\C-cg" 'writegood-mode)


;;------------------------------------------------------------------------------
;; display-buffer in emacs-24

;;; IMPORTANT! See `split-window-preferred-function', the threshold is used in
;;; `split-window-sensibly'. This is how you control splitting in large
;;; displays. These are thresholds.

;; Ensure vertical split for new windows almost everywhere; For large displays,
;; behave the same.
(setq split-height-threshold 200)
(setq split-width-threshold 300)



;;------------------------------------------------------------------------------
;; Conf mode additions

(require 'conf-mode)
(define-key* conf-mode-map [(control c)(control ?\\)] 'sh-backslash-region)



;;------------------------------------------------------------------------------
;; Global function to append some character to the end of a region.

;; Stolen and adapted from makefile-backslash-region.
(defun backslash-region (from to delete-flag)
  "Insert, align, or delete end-of-line backslashes on the lines in the region.
With no argument, inserts backslashes and aligns existing backslashes.
With an argument, deletes the backslashes.

This function does not modify the last line of the region if the region ends
right at the start of the following line; it does not modify blank lines
at the start of the region.  So you can put the region around an entire macro
definition and conveniently use this command."
  (interactive "r\nP")
  (let ((char (read-char "Character: " )))
    (save-excursion
      (goto-char from)
      (let ((column makefile-backslash-column)
            (endmark (copy-marker to)))
        ;; Compute the smallest column number past the ends of all the lines.
        (when (and makefile-backslash-align (not delete-flag))
          (while (< (point) to)
            (end-of-line)
            (if (= (preceding-char) char)
                (progn (forward-char -1)
                       (skip-chars-backward " \t")))
            (setq column (max column (1+ (current-column))))
            (forward-line 1))
          ;; Adjust upward to a tab column, if that doesn't push
          ;; past the margin.
          (if (> (% column tab-width) 0)
              (let ((adjusted (* (/ (+ column tab-width -1) tab-width)
                                 tab-width)))
                (if (< adjusted (window-width))
                    (setq column adjusted)))))
        ;; Don't modify blank lines at start of region.
        (goto-char from)
        (while (and (< (point) endmark) (eolp))
          (forward-line 1))
        ;; Add or remove backslashes on all the lines.
        (while (and (< (point) endmark)
                    ;; Don't backslashify the last line
                    ;; if the region ends right at the start of the next line.
                    (save-excursion
                      (forward-line 1)
                      (< (point) endmark)))
          (if (not delete-flag)
              (backslash-append-char column char)
            (backslash-delete-char char))
          (forward-line 1))
        (move-marker endmark nil)))))

(defun backslash-append-char (column char)
  (end-of-line)
  ;; Note that "\\\\" is needed to get one backslash.
  (if (= (preceding-char) ?\\)
      (progn (forward-char -1)
             (delete-horizontal-space)
             (indent-to column (if makefile-backslash-align nil 1)))
    (indent-to column (if makefile-backslash-align nil 1))
    (insert char)))

(defun backslash-delete-char (char)
  (end-of-line)
  (or (bolp)
      (progn
 	(forward-char -1)
 	(if (looking-at (regexp-quote (char-to-string char)))
 	    (delete-region (1+ (point))
 			   (progn (skip-chars-backward " \t") (point)))))))

(define-key* ctl-x-map [(control ?\\)] 'backslash-region)

;;------------------------------------------------------------------------------
;; A function that will ensure a common prefix and suffix to every line in a
;; region.

;; (This may not make sense after all... I do want to preserve whitespace.
;; Keep it in case I want to revive it.)

;; (defun wrap-lines-in-region (beg end prefix suffix)
;;   "Set point and mark, and all the lines in the region will be
;; formatted with the given prefixes and suffixes. The prefix/suffix
;; are preserved if already present."
;;   (interactive "r\nsPrefix: \nsSuffix: ")
;;   (let* ((line-beg (line-number-at-pos beg))
;; 	 (line-end (line-number-at-pos end))
;; 	 (line line-beg))
;;     (save-excursion
;;       (while (< line line-end)
;; 	(goto-line line)
;;         (back-to-indentation)
;;         (unless (looking-at prefix)
;;           (insert prefix))
;;         (move-end-of-line nil)
;;         (unless (looking-back suffix)
;;           (insert suffix))
;; 	(incf line)
;;         ))))


;;--------------------------------------------------------------------------------
;; A function that allows you to easily obfuscate/randomize some of the
;; characters in a text file.

(defun insert-randomized-text ()
  "A function that allows you to easily obfuscate/randomize some
of the characters in a text file. Numbers are treated specially,
attempting not to change them by too large an amount."
  (interactive)
  (let* ((next-char (following-char))
         (next-string (char-to-string next-char))
         (case-fold-search nil))
    (cond
     ((string-match "[a-z]" next-string)
      (delete-char 1)
      (insert (char-to-string (+ (random 26) ?a))))

     ((string-match "[A-Z]" next-string)
      (delete-char 1)
      (insert (char-to-string (+ (random 26) ?A))))

     ((string-match "[0-9]" next-string)
      ;; FIXME: If this is the first number, don't change it, the second change
      ;; it with low probability, and further forward with high probability
      (delete-char 1)
      (insert (char-to-string (+ (mod (+ (- next-char ?0) (- (random 5) 2)) 10) ?0))))
     (t
      (forward-char 1))
     )))

(when (featurep 'repeatable)
  (repeatable-command-advice insert-randomized-text))
(define-key* text-mode-map [(control c)(j)] 'insert-randomized-text)
;(define-key* global-map [(control c)(j)] 'insert-randomized-text)


;;--------------------------------------------------------------------------------
;; Highlight line numbers
(when nil
  (global-linum-mode -1)
  (setq linum-format "%4d \u2502"))


;;--------------------------------------------------------------------------------
;; Sort lines

(global-set-key* [(control c)(s)] 'sort-lines)



;;--------------------------------------------------------------------------------
;; From any mode, replace the last sexp by its output

;; From +mattpi
(defun replace-last-sexp ()
  (interactive)
  (let ((value (eval (preceding-sexp))))
    (kill-sexp -1)
    (insert (format "%S" value))))



;;;; ==========================================================================
;;;; *
;;;; *  Non-Standard Packages
;;;; *
;;;; ==========================================================================

;;------------------------------------------------------------------------------
;; caps-mode

(when (require 'caps-mode nil t)

  (global-set-key* [(control c)(u)] 'caps-mode)

  ;; Also make dashes translate into underscores in that mode.
  (define-key caps-mode-map (kbd "-") (lambda () (interactive (insert "_"))))
  )


;;------------------------------------------------------------------------------
;; Support for invocation from shells.

(defun find-file-at-line (filename line)
  "Opens the given filename and center and highlight at the given
  line number."
  (find-file filename)
  (goto-line line)
  (recenter)
  (set-mark (point))
  (next-line) )


;;------------------------------------------------------------------------------
;; expand-region

;; Note: I just need a good key for this.
(when nil ;; (require 'expand-region nil t)
  (global-set-key* [(control ?@)] 'er/expand-region)
  )


;;------------------------------------------------------------------------------
;; multiple-cursors

;;  - `mc/mark-next-like-this`: Adds a cursor and region at the next part of the buffer forwards that matches the current region.
;;  - `mc/mark-next-word-like-this`: Like `mc/mark-next-like-this` but only for whole words.
;;  - `mc/mark-next-symbol-like-this`: Like `mc/mark-next-like-this` but only for whole symbols.
;;  - `mc/mark-previous-like-this`: Adds a cursor and region at the next part of the buffer backwards that matches the current region.
;;  - `mc/mark-previous-word-like-this`: Like `mc/mark-previous-like-this` but only for whole words.
;;  - `mc/mark-previous-symbol-like-this`: Like `mc/mark-previous-like-this` but only for whole symbols.
;;  - `mc/mark-more-like-this-extended`: Use arrow keys to quickly mark/skip next/previous occurances.
;;  - `mc/add-cursor-on-click`: Bind to a mouse event to add cursors by clicking. See tips-section.

;;  - `mc/mark-all-like-this`: Marks all parts of the buffer that matches the current region.
;;  - `mc/mark-all-words-like-this`: Like `mc/mark-all-like-this` but only for whole words.
;;  - `mc/mark-all-symbols-like-this`: Like `mc/mark-all-like-this` but only for whole symbols.
;;  - `mc/mark-all-in-region`: Prompts for a string to match in the region, adding cursors to all of them.
;;  - `mc/mark-all-like-this-in-defun`: Marks all parts of the current defun that matches the current region.
;;  - `mc/mark-all-words-like-this-in-defun`: Like `mc/mark-all-like-this-in-defun` but only for whole words.
;;  - `mc/mark-all-symbols-like-this-in-defun`: Like `mc/mark-all-like-this-in-defun` but only for whole symbols.
;;  - `mc/mark-all-like-this-dwim`: Tries to be smart about marking everything you want. Can be pressed multiple times.

;;  - `set-rectangular-region-anchor`: Think of this one as `set-mark` except you're marking a rectangular region.
;;  - `mc/mark-sgml-tag-pair`: Mark the current opening and closing tag.
;;  - `mc/insert-numbers`: Insert increasing numbers for each cursor, top to bottom.
;;  - `mc/sort-regions`: Sort the marked regions alphabetically.
;;  - `mc/reverse-regions`: Reverse the order of the marked regions.

;; Note: I wish that this was included in multiple-cursors.
(when (< emacs-major-version 25)
  (when (require 'inline-string-rectangle nil t)

    (defun inline-string-rectangle-maybe ()
      "Dispatch to either string-rectangle or inline-string-rectangle depending
     on whether the region is taller than the height of the window."
      (interactive)
      (call-interactively
       (if (or current-prefix-arg
               (> (count-lines (region-beginning) (region-end)) (/ (window-height) 2)))
           'string-rectangle 'inline-string-rectangle)))

    ;; Override string-rectangle with a better definition.
    (substitute-key-definition 'string-rectangle 'inline-string-rectangle-maybe
                               (current-global-map))

    ))

(when (require 'multiple-cursors nil t)
  (global-set-key (kbd "C-x r e") 'mc/edit-lines)
  (global-set-key (kbd "C-x r u") 'set-rectangular-region-anchor)

  (global-set-key* [(control c)(?<)] 'mc/mark-previous-like-this)
  (global-set-key* [(control c)(?>)] 'mc/mark-next-like-this)
  (global-set-key* (kbd "C-M-m") 'mc/mark-more-like-this) ; like the other two, but takes an argument (negative is previous)
  (global-set-key* [(control c)(?*)] 'mc/mark-all-like-this)

  ;; FIXME: Those don't work, I don't now why.
  ;; (repeatable-command-advice mark-previous-like-this)
  ;; (repeatable-command-advice mark-next-like-this)

  ;; Make it possible to start this from isearch
  (defadvice mc/mark-previous-like-this (before isearch-to-region activate)
    (set-mark isearch-other-end))
  (defadvice mc/mark-next-like-this (before isearch-to-region activate)
    (set-mark isearch-other-end))
  (defadvice mc/mark-more-like-this (before isearch-to-region activate)
    (set-mark isearch-other-end))
  (defadvice mc/mark-all-like-this (before isearch-to-region activate)
    (set-mark isearch-other-end))

  (add-hook 'sgml-mode-hook
            (lambda ()
              (require 'rename-sgml-tag)
              (define-key* sgml-mode-map (kbd "C-c C-r") 'rename-sgml-tag)))
  )


;;------------------------------------------------------------------------------
;; key-chords

(when (require 'key-chord nil t)
  ;;(key-chord-mode 0)

  ;; This is just waiting to get used like crazy... bind stuff!
  (dolist (x '( ("a]" . "") ("a[" . "")
                ("e]" . "") ("e[" . "")
                ("i]" . "") ("i[" . "")
                ("o]" . "") ("o[" . "")
                ("u]" . "") ("u[" . "")

                ("a7" . "") ("a5" . "") ("a6" . "")
                ("e7" . "") ("e5" . "") ("e6" . "")
                ("i7" . "") ("i5" . "") ("i6" . "")
                ("o7" . "") ("o5" . "") ("o6" . "")
                ("u7" . "") ("u5" . "") ("u6" . "")

                ("c," . "")
                ))

    (key-chord-define-global (car x) `(lambda () (interactive) (insert ,(cdr x))))
    )

  )

;;------------------------------------------------------------------------------
;; ace-jump-mode

(when (require 'ace-jump-mode nil t)
  ;; (global-set-key* [(control c)(?0)] 'ace-jump-mode)
  ;; (global-set-key* [(control c)(? )] 'ace-jump-mode)
  (global-set-key* [(control meta s)] 'ace-jump-mode)

  )


;;------------------------------------------------------------------------------
;; csh-mode

(autoload 'csh-mode "csh-mode" "Major mode for editing csh scripts" t)


;;------------------------------------------------------------------------------
;; sh-mode

(require 'sh-script)


;;------------------------------------------------------------------------------
;; winmgr-mode

(autoload 'winmgr-mode "winmgr-mode"
  "Major mode for editing winmgr config files" t)

;;------------------------------------------------------------------------------
;; Alignment

(require 'align)
;;    (setq align-indent-before-aligning t)

(defun align-commas (beg end)
  "Align all the commas in the region."
  (interactive "r")
  (dotimes (x 5)
    (align-regexp beg end "\\(\\s-*\\)," 1 0 t)
    (align-regexp beg end ",\\(\\s-*\\)" 1 1 t)))
  ;; (align-entire beg end
  ;;               '((commas-as-table
  ;;                  (regexp . "\\(\\s-*\\)\\,\\(\\s-*\\)")
  ;;                  (repeat . t)
  ;;                  (group 1 2)
  ;;                  ))
  ;;               '())


(global-set-key* [(control c)(m)] 'align-regexp)

(when (require 'cc-smart-align nil t)

  (defun c++-param-cycle-comma () (interactive)
    (c++-param-cycle-indentation "," (if current-prefix-arg " " "") t))

  (defun c++-param-cycle-semicolon () (interactive)
    (c++-param-cycle-indentation "," (if current-prefix-arg " " "") t))

  (when (featurep 'repeatable)
    (repeatable-command-advice c++-param-cycle-comma)
    (repeatable-command-advice c++-param-cycle-semicolon) )
  )

(require 'cc-param-cycle nil t)

(define-key* c-mode-base-map [(control c)(n)] 'c++-align-parameters)
;(define-key* c-mode-base-map [(control c)(b)] 'c++-align-data-members)
(define-key* c-mode-base-map [(control c)(v)] 'smart-align-text)
(define-key* c-mode-base-map [(control c)(\\)] 'c-multiline-string-fixup)

;; FIXME: make these "C" common names, it's not just for C++.
(define-key* c-mode-base-map [(control c)(\;)] 'c++-param-cycle-comma)
(define-key* c-mode-base-map [(control c)(\:)] 'c++-param-cycle-semicolon)



(when (< emacs-major-version 24)
  ;; Remove the comment-column limitation on aligning C comments.
  (assq-delete-all 'column (cdr (assq 'c++-comment align-rules-list))) )



(defun c-multiline-string-fixup (beg end)
  "Replace or remove (with prefix arg) trailing \n\ chars within the region.
This is useful for editing multi-line strings in C."
  (interactive "r")
  (let ((mbeg (set-marker (make-marker) beg))
        (mend (set-marker (make-marker) end)))

    ;; Remove the current postfixes.
    (goto-char mbeg)
    (while (< (point) mend)
      (when (re-search-forward "\\\\n\\\\" (line-end-position) t)
        (goto-char (match-beginning 0))
        (delete-char 3))
      (forward-line 1))

    (unless current-prefix-arg
      ;; Add the postfixes back in.
      (goto-char mbeg)
      (while (< (point) mend)
        (end-of-line)
        (insert "\\n\\")
        (forward-line 1)))

    ;; Clear markers.
    (dolist (x (list mbeg mend)) (set-marker x nil))
  ))

;; FIXME: This needs a binding.
(defun align-table (beg end &optional delim)
  "Align region as a table using the given delimiter character."
  (interactive "r")
  (let ((delim (or delim ";"))
        (align-indent-before-aligning nil))
    (align-region beg end 'entire
                  `((table-line
                     (regexp . ,(format "\\([ \t]*\\)%s" delim))
                     (group . 1)
                     (repeat . t)))
                  nil
                  )))


;;------------------------------------------------------------------------------
;; Block region marking.

(when (require 'boxquote nil t)

  (define-prefix-command 'ctl-x-ctl-b-map)
  (global-set-key* [(control c)(control b)] ctl-x-ctl-b-map)

  (define-key* ctl-x-ctl-b-map [(r)] 'boxquote-region)
  (define-key* ctl-x-ctl-b-map [(p)] 'boxquote-paragraph)
  (define-key* ctl-x-ctl-b-map [(d)] 'boxquote-defun)
  (define-key* ctl-x-ctl-b-map [(u)] 'boxquote-unbox)
  (define-key* ctl-x-ctl-b-map [(s)] 'boxquote-unbox-region) ;; ?
  (define-key* ctl-x-ctl-b-map [(t)] 'boxquote-title)
  (define-key* ctl-x-ctl-b-map [(k)] 'boxquote-kill)
  (define-key* ctl-x-ctl-b-map [(control y)] 'boxquote-yank)
  (define-key* ctl-x-ctl-b-map [(y)] 'boxquote-yank)

  (defun thinks-maybe-region ()
    "If region is active, bubble wrap region bounding START and END.
If not, query for text to insert in bubble."
    (interactive)
    (if mark-active
	(call-interactively 'thinks-region)
      (call-interactively 'thinks)))

  ;; Add narrow-to-boxquote to standard narrow keymap.
  (define-key* (lookup-key ctl-x-map [(n)]) [(b)] 'boxquote-narrow-to-boxquote)

  )


;;------------------------------------------------------------------------------

(defun map-parent-dirs (dir fun)
  "Given a directory DIR, run through the list of all parent
directories, from the leaf to the root, calling FUN for each
component.  If FUN returns non-nil, we stop the iteration."
  (interactive)
  (let ((dir (expand-file-name (file-name-as-directory dir)))
        res)
    (while dir
      (setq res (funcall fun dir))
      (setq dir
            (unless (or res (string= dir "/"))
              (expand-file-name (file-name-directory
                                 (directory-file-name
                                  (file-name-directory dir))))))
      )
    res))

(defun find-file-nearest-todo (&optional buf)
  "Find the nearest 'todo' file in the parent directories of the
current buffer."
  (interactive)
  (let ((filename (or buf (buffer-file-name) default-directory)))
    (if filename
        (let ((todo
               (map-parent-dirs
                filename
                (lambda (dir)
                  (some (lambda (x)
                          (let ((todo (concat dir x)))
                            (and (file-exists-p todo) todo)))
                        '("TODO"
                          "TODO.txt"
                          "todo"
                          "todo.txt"
                          "ChangeLog"
                          "CHANGES"
                          "README"
                          "README.txt")))
                )))
          (if todo
              (progn (find-file todo)
                     (message "Found nearest todo file: %s" todo))
            (message "No todo file found.")
            ))
      (message "No todo file found.")
      )))

(define-key* ctl-x-map "rh" 'find-file-nearest-todo)


;;------------------------------------------------------------------------------
;; SGML

(when (require 'nxml-mode nil t)

  ;; Replace all xml-mode settings to nxml-mode.
  (dolist (c auto-mode-alist)
    (if (or (eq (cdr c) 'xml-mode) (eq (cdr c) 'html-mode))
	(setcdr c 'nxml-mode)
      ))

  (when (boundp 'magic-mode-alist)
    (dolist (c magic-mode-alist)
      (if (or (eq (cdr c) 'xml-mode) (eq (cdr c) 'html-mode))
	  (setcdr c 'nxml-mode)
	)))

  (add-to-list 'auto-mode-alist '("\\.rn[gc]\\'" . nxml-mode))

  (custom-set-variables '(nxml-child-indent 2))

  (defun user-nxml-mode-hook ()
    (setq indent-tabs-mode nil)
   )
  (add-hook 'nxml-mode-hook 'user-nxml-mode-hook)



  ;; Replace rng-locate-scheme-file to search for all files up the directory
  ;; path.
  (require 'rng-loc)

  ;; (fset 'rng-locate-schema-file-orig
  ;;       (symbol-function 'rng-locate-schema-file))
  ;;
  ;; (defun rng-locate-schema-file (&optional type-id)
  ;;    (let ((rng-schema-locating-files
  ;;           (append
  ;;            rng-schema-locating-files
  ;;            (filter 'file-exists-p
  ;;                    (mapcar (lambda (x) (concat x "schemas.xml"))
  ;;                            (all-parent-dirs (buffer-file-name)))))))
  ;;      (rng-locate-schema-file-orig)))
  ;;
  ;; ;;(setq nxml-mode-hook nil)
  ;; (add-hook
  ;;  'nxml-mode-hook
  ;;  (lambda ()
  ;;     (local-set-key*
  ;;      [(control c)(meta w)]
  ;;      (lambda () (interactive)
  ;;        (let ((rng-schema-locating-files
  ;;               (filter 'file-exists-p
  ;;                       (mapcar (lambda (x) (concat x "schemas.xml"))
  ;;                               (all-parent-dirs (buffer-file-name))))))
  ;;                      (message "%s" rng-schema-locating-files))))))

  (when nil
    ;; Faces for nxml-mode.
    (set-face-attribute 'nxml-comment-content-face nil
			:foreground "#AAAAAA")
    (set-face-attribute 'nxml-comment-delimiter-face nil
			:foreground "#BBBBBB")

    (mapcar
     (lambda (x) (set-face-attribute x nil :foreground "#FF4040"))
     (list 'nxml-processing-instruction-delimiter-face
	   'nxml-processing-instruction-content-face
	   'nxml-processing-instruction-target-face))

    (set-face-attribute 'nxml-attribute-local-name-face nil
			:foreground "#2020E0")
    (set-face-attribute 'nxml-attribute-local-name-face nil
			:foreground "#2020E0")
    (set-face-attribute 'nxml-attribute-value-face nil
			:foreground "#2020A0")

    (setq nxml-slash-auto-complete-flag t)
    )
  )


;;; Old psgml-mode config, nxml is much much better.
;;;-------------------------------------------------
;;; ;; Including sgml-mode that comes with GNU emacs fixes psgml not
;;; ;; working.  This should eventually be removed when it gets fixed
;;; ;; properly.
;;; (require 'sgml-mode)
;;;
;;; (require 'font-lock)
;;;
;;; (autoload 'sgml-mode "psgml" "Major mode to edit SGML files." t)
;;; (autoload 'xml-mode "psgml" "Major mode to edit XML files." t)
;;;
;;; ;; (add-to-list 'auto-mode-alist '("\\.xml\\'" . xml-mode))
;;;
;;; (setq sgml-set-face t)
;;;
;;; (if t
;;;     (progn
;;;
;;;     (setq after-change-function nil)
;;;     (autoload 'sgml-mode "psgml" "Major mode to edit SGML files." t)
;;;     (autoload 'xml-mode "psgml" "Major mode to edit XML files." t)
;;;
;;;     (add-hook 'sgml-mode-hook '(lambda () (setq truncate-lines t)))
;;;
;;;     (setq sgml-local-catalogs (list "..../dtd"))
;;;
;;;     (setq sgml-indent-data t)
;;;     (setq sgml-set-face t)
;;;     ;; C-c / end tag
;;;
;;;     (setq sgml-auto-insert-required-elements nil)
;;;     (setq sgml-general-insert-case 'lower)
;;;
;;;     ;; psgml-xpointer
;;;     ;;(autoload 'sgml-xpointer "psgml-xpointer" nil t)
;;;
;;;     ;; (setq sgml-markup-faces '((start-tag  . function-name-face)
;;;     ;;                           (end-tag    . function-name-face)
;;;     ;;                           (comment    . comment-face)
;;;     ;;                           (ignored    . comment-face)
;;;     ;;                           (pi         . keyword-face)
;;;     ;;                           (sgml       . keyword-face)
;;;     ;;                           (doctype    . type-face)
;;;     ;;                           (entity     . string-face)
;;;     ;;                           (shortref   . bold)))
;;;
;;;
;;;     ;; ** New commands iso-iso2sgml and iso-sgml2iso convert
;;;     ;; between Latin-1 characters and the corresponding SGML
;;;     ;; (HTML) entities.
;;;
;;;     ))

;;------------------------------------------------------------------------------
;; HTML and wdg's validate

(defun user-html-mode-hook ()
  (let ((fn (file-relative-name buffer-file-name default-directory)))
    (make-local-variable 'compile-command)
    ;;(setq compile-command (concat "validate --emacs " fn))
    (setq compile-command (concat "xmllint --html --noout --valid " fn))
    ;;(make-local-variable 'compilation-error-regexp-alist)
    ;;(add-to-list 'compilation-error-regexp-alist
    ;;           (list "Line \\([0-9]+\\), character \\([0-9]+\\):" 0 1 2 fn))

    ))


(defun user-sgml-mode-hook ()
  (let ((fn (file-relative-name buffer-file-name default-directory)))
    (make-local-variable 'compile-command)
    (setq compile-command (concat "xmllint --noout --valid " fn))
    ;;(make-local-variable 'compilation-error-regexp-alist)
    ;;(add-to-list 'compilation-error-regexp-alist
    ;;           (list "Line \\([0-9]+\\), character \\([0-9]+\\):" 0 1 2 fn))
    ))

;; Note[2014-03-02]: This causes a problem with org-mode export to HTML.
;; I have things to do--disabling for now.
;; (add-hook 'html-mode-hook 'user-html-mode-hook)
;; (add-hook 'sgml-mode-hook 'user-sgml-mode-hook)


;;------------------------------------------------------------------------------
;; docbook

;; DocBook IDE mode
;;(autoload 'docbook-mode "docbookide" "Major mode for DocBook documents." t)

;; You might want to make this the default for .sgml or .xml documents,
;; or you might want to rely on -*- DocBook -*- on the first line,
;; or perhaps buffer variables. It's up to you...
;;(setq auto-mode-alist
;;      (append
;;       (list
;;      '("\\.sgm" . docbook-mode))
;;      '("\\.sgml" . docbook-mode))
;;      '("\\.xml" . docbook-mode))
;;       auto-mode-alist))

;;------------------------------------------------------------------------------
;; PHP mode

(when (require 'php-mode nil t)
  (add-to-list 'auto-mode-alist '("\\.php\\'" . php-mode)) )


;;------------------------------------------------------------------------------
;; Support for editing encrypted files.
;;
;; REQUIREMENTS:
;; - Encrypted files should be read-only buffers
;; - We should be warned about saving decrypted files, prevented
;; - We want to be in MC-r mode to read the encrypted data, and in MC-w
;;   mode to read decrypted data.
;; - We want to change the filename when decrypted.
;; - We should be able to take a normal file and to save it encrypted
;;   easily, and the modes should work fine.
;; - When there is no visited filename, killing the buffer should require
;;   confirmation

(when t
  ;; Newer configuration using EasyPG over mailcrypt.
  ;;
  ;; This setup works with GPG 2.1 and above, and either
  ;;   pinentry-program /usr/bin/pinentry-tty
  ;; or
  ;;   pinentry-program /usr/bin/pinentry-curses
  ;; in gpg-agent.conf
  ;;
  ;;(require 'epa-file)

  ;; Without this reading passwords will be kludkey (keys sharing the tty with
  ;; another program).
  (setq epa-pinentry-mode 'loopback)

  (setq epa-file-name-regexp "\\.\\(gpg\\|\\asc\\)$")
  (epa-file-name-regexp-update)

  (setq epa-armor t
        epa-textmode t)

  ;;(epa-file-enable)
  )


;;------------------------------------------------------------------------------
;; outline / org-mode

(add-first-found-to-load-path
 (concat home "/src/elisp/org-mode-readonly/lisp")
 (concat home "/src/org-mode-readonly/lisp")
 (concat home "/src/org-mode/lisp")
 )



(when (featurep 'repeatable)
  (repeatable-command-advice backward-page)
  (repeatable-command-advice forward-page) )

(require 'outline)

(when (featurep 'repeatable)
  (repeatable-command-advice outline-next-visible-heading)
  (repeatable-command-advice outline-previous-visible-heading)
  (repeatable-command-advice outline-up-heading) )

(require 'org)

(when (featurep 'repeatable)
  (repeatable-command-advice org-forward-same-level)
  (repeatable-command-advice org-backward-same-level) )

(define-key* org-mode-map [(control c) (control r)] 'rst-shift-region-right)
(define-key* org-mode-map [(control c) (control l)] 'rst-shift-region-left)

(define-key* org-mode-map [(control c)(l)] 'org-store-link)
(define-key* org-mode-map [(control c)(a)] 'org-agenda)


;;------------------------------------------------------------------------------
;; Visual Basic

(autoload 'vbnet-mode "vbnet-mode"
  "A mode for editing Visual Basic programs.")


;;------------------------------------------------------------------------------
;; Haskell

(setq auto-mode-alist
      (append auto-mode-alist
              '(("\\.[hg]s$"  . haskell-mode)
                ("\\.hi$"     . haskell-mode)
                ("\\.l[hg]s$" . literate-haskell-mode))))

(autoload 'haskell-mode "haskell-mode"
  "Major mode for editing Haskell scripts." t)
(autoload 'literate-haskell-mode "haskell-mode"
  "Major mode for editing literate Haskell scripts." t)

(when (require 'haskell-font-lock nil t)

  (add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
  ;;(add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
  ;;(add-hook 'haskell-mode-hook 'turn-on-haskell-hugs)
  ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)

  (defun user-haskell-mode-hook ()
    (setq indent-tabs-mode nil)
    )

  (add-hook 'haskell-mode-hook 'user-haskell-mode-hook)
  ;; Note: we need both because of careless overrides in haskell-doc-mode.
  (add-hook 'haskell-doc-mode-hook 'user-haskell-mode-hook)
  )


;;------------------------------------------------------------------------------
;; Erlang

(when (require 'erlang-start nil t)
  (load "/etc/emacs/site-start.d/50erlang-mode.el" t))



;;------------------------------------------------------------------------------
;; Inferior LISPs.


;; Setup for Clojure.
(when t
  (setq inferior-lisp-program (format "make -C %s/notepad/cljsrepl repl" user-projects-root)
	inferior-lisp-load-command "(load \"%s\")\n"
	lisp-function-doc-command "(doc %s)\n"
	lisp-var-doc-command "(doc %s)\n"
	lisp-describe-sym-command "(doc %s)\n"
	lisp-arglist-command "'(a b c)"
	))

;(defun inferior-lisp-proc () inferior-lisp-buffer)


;; Setup for SBCL.
(when nil
  (setq inferior-lisp-program "sbcl --noinform"
	;; Have to reset the path to be relative b/c Ubuntu overrides it otherwise.
	slime-backend "swank-loader.lisp"
	slime-net-coding-system 'utf-8-unix
	slime-lisp-host "localhost"
	slime-port 4005
   ))


;;------------------------------------------------------------------------------
;; SLIME setup.

(defvar user-slime-root
  ;(concat home "/src/slime-technomancy") ;; The bleeding edge SLIME doesn't work with Clojure yet.
  nil
  "Override for bleeding edge version of SLIME.")

(when (and user-slime-root (file-exists-p user-slime-root))
  (add-to-list 'load-path user-slime-root) )

(defvar user-slime-contribs '(slime-repl
			      slime-fuzzy
			      slime-editing-commands)
  "Desired extensions for SLIME.")



;; Setup for slime-js
(when nil
  ;; You'll need to patch swank-js: https://github.com/ivan4th/swank-js/issues/12
  (add-to-list 'load-path (concat home "/src/swank-js"))
  (add-hook 'js2-mode-hook (lambda () (slime-js-minor-mode 1)))

  (add-hook 'css-mode-hook
	    (lambda ()
	      (define-key* css-mode-map "\M-\C-x" 'slime-js-refresh-css)))

  (setq user-slime-contribs (append user-slime-contribs '(slime-js)))
  )


;; Current set of problems with SLIME and Clojure:
;; - Usage without slime-repl is impossible, (:write-string) REX fails
;; - Auto-connect doesn't work because it assumes starting an inferior process
;;   via (slime) and we want to (slime-connect)
;; - The latest version doesn't work; it has some issue with string encoding

(when (and (not (equal (getenv "SITE") "google"))
           (require 'slime nil t))

  (add-to-list 'auto-mode-alist '("\\.lisp$" . lisp-mode))
  (add-to-list 'auto-mode-alist '("\\.cl$" . lisp-mode))
  (add-to-list 'auto-mode-alist '("\\.asd$" . lisp-mode))

  ;; Remove slime bindings conflicting with our own.
  (dolist (key '("\M-n" "\M-p"))
    (define-key* slime-mode-map key nil))

  ;; (slime-setup)
  ;; Note: this uses flet, unfortunately.
  (slime-setup user-slime-contribs)

  (defun slime-eval-at-register (reg)
    "Take the cursor to a register's location and eval
     the expression there. Useful for testing stuff without
     having to 'go there' first."
    (interactive "cEval at register: ")
    (save-excursion
      (jump-to-register reg)
      (slime-eval-last-expression)))

  ;; Note: slime-interactive-eval is also available on C-c :,
  ;; so we override it for something that looks like C-x C-e.
  (define-key* slime-mode-map "\C-c\C-e" 'slime-eval-at-register)

   ;; Ignore version mismatch.
  (setq slime-protocol-version 'ignore)

  ;; Much more convenient UTF-8 coding for modern Lisps (e.g. clj).
  (setq slime-net-coding-system 'utf-8-unix)


  ;; Configuration to make slime-auto-connect work properly with Clojure.

  ;; Override the default command to support optinal network connection instead of
  ;; always just starting an inferior process.
  (defadvice slime (around slime-auto-net-connect activate)
    (if slime-default-is-connect
	(save-window-excursion
	  (slime-connect slime-lisp-host slime-port)
	  (sleep-for 0 300))
      ad-do-it))

  ;; Automatically connect when disconnected.
  (setq slime-auto-connect 'always)

  ;; Indicate that the default connection should be via the network, not an
  ;; inferior process.
  (setq slime-default-is-connect t)



  ;; This is the solution I originally came up with in order to easily and
  ;; automatically reconnect.
  (when nil
  (defun slime-reconnect ()
    "A more convenient function to reconnect to a LISP VM. This
    function uses the default parameters for the connection so
    you don't have to specify them, on failure waits and retries
    automatically until the connection succeeds (for slow VMs to
    start in the background), and saves and restores the window
    configuration to avoid showing the repl (you don't need it
    most of the time if you use SLIME)."
    (interactive)
    (slime-disconnect-all)
    (message "Connecting to Swank on port %S.." slime-port)
    (save-window-excursion
      (let ((count 0))
	(while (not
		(condition-case nil
		    (let* ((process (slime-net-connect slime-lisp-host slime-port slime-net-coding-system))
			   (slime-dispatching-connection process))
		      (slime-setup-connection process)
		      )
		  (error
		   ;;(message "Waiting for VM...")
		   (sleep-for 0 700)
		   (message (format "Attempting reconnection to Swank... (%s times)" count))
		   (setq count (1+ count) )
		   nil))))
	(sleep-for 0 300)
	)))
  (defalias 'sc 'slime-reconnect)
  (defalias 'sr 'slime-reconnect)
  )


  ;; Debugger enhancements for SLIME.

  (defun sldb-line-bp ()
    "Set breakpoint on current buffer line."
    (interactive)
    (slime-eval-async `(swank:sldb-line-bp
			,(buffer-file-name) ,(line-number-at-pos))))
  (global-set-key* "\C-x\C-a\C-b" 'sldb-line-bp)

  (defun slime-force-continue ()
    "force swank server to continue"
    (interactive)
    (slime-dispatch-event `(:emacs-interrupt :cdt)))
  (global-set-key* "\C-x\C-a\C-g" 'slime-force-continue)

  (defun slime-get-thing-at-point ()
    (interactive)
    (let ((thing (thing-at-point 'sexp)))
      (set-text-properties 0 (length thing) nil thing)
      thing))

  (defun slime-eval-last-frame ()
    "Eval thing at point in the context of the last frame viewed"
    (interactive)
    (slime-eval-with-transcript `(swank:eval-last-frame
				  ,(slime-get-thing-at-point))))
  (global-set-key* "\C-x\C-a\C-p" 'slime-eval-last-frame)

  )


;;------------------------------------------------------------------------------
;; Clojure

;; User customization.
(defvar user-clojure-mode 'cider
  "Which mode we're using for editing Clojure code.")

(defvar user-clojure-setup-test t
  "True if we want to setup clojure-test mode and hooks.")

(defvar user-clojure-setup-debugging nil
  "True if we want to setup experimental debugging support.")

(defvar user-clojure-projects-root (concat home "/c")
  "Root of all Clojure project clones.")



;; Override for bleeding edge version of clojure-mode.
(dolist (path (list
               ;; (concat home "/c/clojure-mode")
               ;; (concat home "/c/clojure-emacs/cider")
               ;; (concat home "/c/nrepl.el")
               ;; (concat home "/c/dash.el")
               ;; (concat home "/c/pkg-info.el")
               ;; (concat home "/c/epl")
               ))
  (when (file-exists-p path)
    (add-to-list 'load-path path)))


(when (require 'clojure-mode nil t)

  (define-key* clojure-mode-map [(\))] 'close-matching)

  ;; Major mode initialization.
  (cond
   ;;========================================
   ((eq user-clojure-mode 'inferior)
    )


   ;;========================================
   ((eq user-clojure-mode 'cider)

    (when (require 'cider nil t)

      ;; Set the default port.
      (setq nrepl-port "4006")

      ;; Automatically focus the error buffer.
      (setq cider-auto-select-error-buffer t)

      ;; Remove underline that looks awful under tmux.
      (set-face-attribute 'cider-error-highlight-face nil :underline nil)
      (set-face-attribute 'cider-warning-highlight-face nil :underline nil)
      ))


   ;;========================================
   ((eq user-clojure-mode 'nreplel)

    (autoload 'nrepl-jack-in "nrepl" "Launch an nrepl server and a repl client." t)
    (autoload 'nrepl "nrepl" "Connect to an already-running nrepl server." t)
    (autoload 'nrepl-connect "nrepl" "Connect to an already-running nrepl server." t)

    (setq nrepl-log-events t)

    (defun nrepl-reconnect ()
      (interactive)
      (nrepl-connect "localhost" 4006))
    (defalias 'nr 'nrepl-reconnect)
    )


   ;;========================================
   ((or (eq user-clojure-mode 'slime) (eq user-clojure-mode 'swank))
    (defun fix-slime-parent-close-binding ()
      (substitute-key-definition 'slime-close-all-parens-in-sexp 'close-matching-all
				 slime-mode-map) )
    (add-hook 'clojure-mode-hook 'fix-slime-parent-close-binding)
    (add-hook 'clojure-mode-hook
	      (lambda () (when (string= mode-name "Clojure") (slime-mode t)))) )
   )


  ;;----------------------------------------------------------------------------
  (when user-clojure-setup-test
    (when (require 'clojure-test-mode nil t)
      (autoload 'clojure-test-mode "clojure-test-mode" "Clojure test mode" t)

      (define-key* clojure-test-mode-map (kbd "M-p") nil)
      (define-key* clojure-test-mode-map (kbd "M-n") nil)

      ;; Automagically turn on test minor mode where it makes sense.
      (defun clojure-test-auto-enable ()
        "Enable clojure-test-mode if the current buffer contains some test stuff."
        (let ((ns (clojure-find-package))) ; defined in clojure-mode.el
          (save-window-excursion
            (when (or (progn (beginning-of-buffer) (search-forward "clojure.test" nil t))
                      (progn (beginning-of-buffer) (search-forward "deftest" nil t)))
              (clojure-test-mode t)))))

      (add-hook 'clojure-mode-hook 'clojure-test-auto-enable)
      )
    )

  ;;----------------------------------------------------------------------------
  (when user-clojure-setup-debugging

    (setq cdt-dir (concat user-clojure-projects-root "/cdt"))
    (load-file (format "%s/ide/emacs/cdt.el" cdt-dir))

    (defun cdt-query-cmdline ()
      (let ((root (concat user-clojure-projects-root "/clojure-binaries/clojure-1.2")))
	(format "java -cp %s clojure.main --repl"
		(mapconcat 'identity (directory-files root t ".*\.jar$") ":"))))

    ;; (setq cdt-sources
    ;; 	  (append (mapcar (lambda (x) (concat home "/c/" x))
    ;; 			  '("clojure/src/jvm"
    ;; 			    "clojure/src/clj"
    ;; 			    "clojure-contrib/src/main/clojure")
    ;; 			  )
    ;; 		  (list (concat user-projects-root "/lang-clojure/src"))))
    ;;
    ;;(add-to-list 'cdt-classpath "/usr/lib/jvm/java-6-sun-1.6.0.22/lib/tools.jar")
    )
  )



;;------------------------------------------------------------------------------
;; ClojureScript

;; Commented out on 2015-12-23 after a long hiatus not using ClojureScript.
;;
;; (defvar user-cljs-mode 'inferior
;;   "Which mode we're using for editing ClojureScript code.")
;;
;; ;; Important: we do not use the cljs-mode provided by clojure-mode, it sucks,
;; ;; has many problems. I just build my own, here.
;; ;;
;; ;; Also, we define this as a major mode because while for Clojure we may want to
;; ;; use SLIME, this may not be the case for ClojureScript, so we keep them
;; ;; separate as much as possible.
;;
;;
;; ;; Setup for Slime ClojureScript support
;; ;;(add-hook 'clojure-mode-hook 'clojure-slime-cljs-hook)
;;
;; ;;;###autoload
;; (define-derived-mode cljs-mode clojure-mode "CLJS"
;;   "Major mode for ClojureScript"
;;
;;   (set (make-local-variable 'inferior-lisp-program)
;;        (format "make -C %s/notepad/cljsrepl repl" user-projects-root))
;;
;;   (when (eq user-cljs-mode 'inferior)
;; 	    ;; Make sure that SLIME is disabled.
;;     (slime-mode -1) )
;;   )
;;
;; ;;;###autoload
;; (add-to-list 'auto-mode-alist '("\\.cljs$" . cljs-mode))


;; Original ClojureScript mode setup... all SNAFU'ed, don't use this.
(when nil
  (require 'clojurescript-mode)
  (setq clojurescript-home (concat home "/c/clojurescript"))
  (setenv "CLOJURESCRIPT_HOME" clojurescript-home)
  (remove-hook 'inferior-lisp-mode-hook 'clojurescript-start-cljs-repl)
  )


;;------------------------------------------------------------------------------
;; Scala

(autoload 'scala-mode "scala-mode" "" t nil)
(add-to-list 'auto-mode-alist (cons "\\.scala$" 'scala-mode))


;;------------------------------------------------------------------------------
;; "Go" language (Google)

(autoload 'go-mode "go-mode" "" t nil)
(add-to-list 'auto-mode-alist (cons "\\.go$" (function go-mode)))

(define-abbrev-table
  'go-mode-abbrev-table
  `(
   ("tr" "" (lambda () (insert-with-replacement "fmt.Printf(\"@ = %v\\n\", @)" "@", "$")))
   ("err" "" (lambda () (insert "
	if err != nil {
		return nil, fmt.Errorf(\"\", err)
	}")))
   ))

;; Indent Go like the rest of Google's code.
(add-hook 'go-mode-hook
          (lambda ()
            (setq tab-width 2)))

;; Gofmt automatically when writing out files.
(setq gofmt-command (concat (getenv "GOPATH") "/bin/goimports"))

(add-hook 'go-mode-hook
          '(lambda ()
             (setq fill-column 100)
             (make-local-variable 'before-save-hook)
             (add-hook 'before-save-hook 'gofmt-before-save)))



;;------------------------------------------------------------------------------
;; Factor (FUEL)

(add-to-list 'auto-mode-alist '("\\.factor\\'" . factor-mode))

(autoload 'factor-mode "factor-mode.el"
  "Major mode for editing Factor source." t)
(autoload 'run-factor "fuel-listener.el"
  "Start a Factor listener, or switch to a running one." t)
(autoload 'switch-to-factor "fuel-listener.el"
  "Start a Factor listener, or switch to a running one." t)
(autoload 'connect-to-factor "fuel-listener.el"
  "Connect to an external Factor listener." t)
(autoload 'fuel-autodoc-mode "fuel-help.el"
  "Minor mode showing in the minibuffer a synopsis of Factor word at point."
  t)
(autoload 'fuel-scaffold-vocab "fuel-scaffold.el"
  "Create a new Factor vocabulary." t)
(autoload 'fuel-scaffold-help "fuel-scaffold.el"
  "Create a Factor vocabulary help file." t)

(setq fuel-factor-root-dir home)
;;(setq factor-mode-use-fuel t)
;;(require 'factor-mode)

;; (mapc (lambda (group)
;;         (custom-add-load group (symbol-name group))
;;         (custom-add-load 'fuel (symbol-name group)))
;;       '(fuel fuel-faces
;;              factor-mode
;;              fuel-autodoc
;;              fuel-stack
;;              fuel-help
;;              fuel-xref
;;              fuel-listener
;;              fuel-scaffold
;;              fuel-debug
;;              fuel-mode))


;;------------------------------------------------------------------------------
;; Chat / IRC

;; erc is an autoload by default now.
(setq erc-server "localhost"
      erc-port 16666
      erc-nick "sproust"
      erc-track-enable-keybindings nil)


;;------------------------------------------------------------------------------
;; Paren completion

;; SMonnier
;; C'est pas bien difficile.  Qqqch du genre
;;
;;    (defun foo ()
;;      (interactive)
;;      (insert-char ?\) (car (syntax-ppss))))
;; ou
;;    (defun foo ()
;;      (interactive)
;;      (let ((current-prefix-arg (car (syntax-ppss)))
;;            (last-command-event ?\)))
;;        (call-interactively 'self-insert-command)))
;;
;; Si tu veux faire mieux, tu peux faire une boucle qui regarde chaque
;; parenthese ouvrante pour inserer la parenthese fermante correspondante
;; (genre ), }, ], ...):
;;
;;    (defun foo ()
;;      (interactive)
;;      (let ((poss (reverse (nth 9 (syntax-ppss)))))
;;        (while poss
;;          (insert (cdr (aref (syntax-table) (char-after (pop poss))))))))
;;
;; je ne trouve pas ce genre de fonction tres utile, personnellement, parce
;; que cela ne fonctionne que pour la toute fin d'une expression top-level.


;;------------------------------------------------------------------------------
;; OCaml

(when nil ;;; Ancient configuration

(setq flavor 'emacs-snapshot) ;; FIXME we should probably not fix it.
;; (load "/etc/emacs/site-start.d/50ocaml-mode.el")
(load "/etc/emacs/site-start.d/51tuareg-mode.el" t)

(setq tuareg-use-abbrev-mode nil)

;; Bind my favorite key for commenting a region.
(add-hook 'tuareg-load-hook
          '(lambda ()
	     ;; Install my own abbrevs.
	     (require 'caml-abbrevs)
	     ))

;; Make some keys repeatable.
(when (featurep 'repeatable)
  (repeatable-command-advice tuareg-next-phrase)
  (repeatable-command-advice tuareg-previous-phrase) )


;; Flymake setup (never tried).
;; http://www.emacswiki.org/cgi-bin/wiki/FlymakeOcaml
(when nil

  (defun flymake-ocaml-init ()
          (flymake-simple-make-init-impl
            'flymake-create-temp-with-folder-structure nil nil
            (file-name-nondirectory buffer-file-name)
            'flymake-get-ocaml-cmdline))
    (defun flymake-get-ocaml-cmdline (source base-dir)
       (list "ocaml_flycheck.pl"
            (list source base-dir)))

    (push '(".+\\.ml[yilp]?$" flymake-ocaml-init flymake-simple-java-cleanup)
          flymake-allowed-file-name-masks)
    (push
      '("^\\(\.+\.ml[yilp]?\\|\.lhs\\):\\([0-9]+\\):\\([0-9]+\\):\\(.+\\)"
       1 2 3 4) flymake-err-line-patterns)

    ;; optional setting
    ;; if you want to use flymake always, then add the following hook.
    ;; (add-hook
    ;;  'tuareg-mode-hook
    ;;  '(lambda ()
    ;;     (if (not (null buffer-file-name)) (flymake-mode))))

    )


;; (defun tuareg-library-find-file ()
;;   "Load the file whose name is near point."
;;   (interactive)
;;   (save-excursion
;;     (if (text-properties-at (point))
;;         (let (beg)
;;           (re-search-backward "\\<") (setq beg (point))
;;           (re-search-forward "\\>")
;;           (let ((fn
;;                  (concat tuareg-library-path "/"
;;                                        (buffer-substring-no-properties
;;                                         beg (point)))))
;;             (prin1 (concat "FILE " fn))
;;             (find-file-read-only fn))))))

)

;;------------------------------------------------------------------------------
;; ESS / R

;; Use the first of the probable install locations.
(add-first-found-to-load-path
 (concat home "/src/ESS/lisp")
 "/usr/local/share/emacs/site-lisp/ess"
 "/usr/share/emacs/site-lisp/ess")

(autoload 'R "ess-site" "Call 'R', the 'GNU S' system from the R Foundation.
Optional prefix (C-u) allows to set command line arguments, such as
--vsize.  This should be OS agnostic.
If you have certain command line arguments that should always be passed
to R, put them in the variable `inferior-R-args'." t)

(autoload 'R-mode "ess-site" "ESS" t)

(add-to-list 'auto-mode-alist (cons "\\.R$" 'R-mode))

(defun user-ess-mode-load-hook ()
  ;; Otherwise C-c C-r (eval region) takes forever
  (setq ess-eval-visibly-p nil)
  ;; Otherwise you are prompted each time you start an interactive R session
  (setq ess-ask-for-ess-directory nil)
  )

(defun user-R-mode-hook ()
  (message "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")

  (ess-toggle-underscore nil)
  (define-key* ess-mode-map [(control x)(control e)] 'ess-eval-paragraph-and-step)
  ;(substitute-key-definition 'ess-smart-underscore 'self-insert-command ess-mode-map)
  )

(add-hook 'ess-mode-load-hook 'user-ess-mode-load-hook)
;;(add-hook 'ess-mode-hook 'user-R-mode-hook)
(add-hook 'inferior-ess-mode-hook 'user-R-mode-hook)
;;(add-hook 'R-mode-hook 'user-R-mode-hook)




;;------------------------------------------------------------------------------
;; python-mode

;; FIXME: Because of Google's configuration, we are not able to use the good old
;; python-mode; we have to use python.el packaged with Emacs (which was
;; essentially selected because of legal/missing FSF signature reasons).
;;
;; Try to detect import override.
;; (defadvice require (before print-require-info activate)
;;   (message (prin1-to-string (ad-get-args 0)))
;;   (when (eq (ad-get-args 0) 'python)
;;     (error "You may not import 'python after having imported 'python-mode")))

(if nil ;; (not (and (>= emacs-major-version 24) (>= emacs-minor-version 3)))
    ;; Use the python-mode from the community
    (progn
      (require 'python-mode nil t)

      ;; Note: python-mode has some support for ipython, not sure how to enable
      ;; it yet.
      (setq-default py-shell-name "ipython")
      (setq py-shell-name "ipython")
      ;; py-which-args '("-pylab")
      ;; py-default-interpreter
      )

  ;; Use python.el which comes with GNU Emacs
  (progn
    (require 'python)

    ;; Fix that enabled abbrevs (see python.el's python-mode-abbrev-table).
    (setq python-skeleton-autoinsert t)

    ;; IPython customizations.
    ;; (require 'ipython nil t)
    ;; (setq py-shell-name "ipython"
    ;;       ;; py-which-args '("-pylab")
    ;;       ;; py-default-interpreter
    ;;       )
    ))


;; Remove that annoyingly stupid compile-like command. I use files damnit.
(substitute-key-definition 'python-shell-send-buffer 'compile python-mode-map)
(substitute-key-definition 'run-python 'compile python-mode-map)




;; (require 'pycomplete)

;;(setq py-indent-offset 3)  ;; 4 is the standard in Python.

(add-to-list 'auto-mode-alist (cons "\\.py$" 'python-mode))
(add-to-list 'auto-mode-alist (cons "SCons\\(truct\\|cript\\)$" 'python-mode))
(add-to-list 'interpreter-mode-alist '("python" . python-mode))
(add-to-list 'interpreter-mode-alist '("python1" . python-mode))
(add-to-list 'interpreter-mode-alist '("python2" . python-mode))
(add-to-list 'interpreter-mode-alist '("python2.3" . python-mode))
(add-to-list 'interpreter-mode-alist '("python2.4" . python-mode))
(add-to-list 'interpreter-mode-alist '("python2.5" . python-mode))
(add-to-list 'interpreter-mode-alist '("python2.6" . python-mode))
(add-to-list 'interpreter-mode-alist '("python2.7" . python-mode))
(add-to-list 'interpreter-mode-alist '("python3.0" . python-mode))
(add-to-list 'interpreter-mode-alist '("python3" . python-mode))

(progn
  (defvar python-working-version "python2.7")
  (setq py-python-command python-working-version)
  (setq py-python-command-args "") ;; Remove the -i
  )

(setq py-python-command
      (if (eq window-system 'w32) "C:/Python27/python.exe" python-working-version))

(require 'make-mode)

;; Move execute-buffer binding to something near our compile binding for C++
(when (fboundp 'python-mode-map)

  (define-key* python-mode-map [(control c)(control c)] nil)
  (define-key* python-mode-map [(control c)(c)] nil)
  (define-key* python-mode-map [(control c)(control e)] 'py-execute-buffer)

  (define-key* python-mode-map [(backspace)] 'backward-delete-char-untabify)
  (define-key* python-mode-map [(control c)(control ?\\)] 'makefile-backslash-region) )

;; Augment the page motion functions to recognize some blank lines
;; as a section separation.  This is not really possible with
;; regexps, because the previous-page movements do not skip
;; backwards properly (even fiddling with the greediness of the
;; match groups), so we use advice to wrap the desired behaviour
;; around the basic page movement methods.
;;
(defadvice forward-page (around blank-forward-page activate)
  (let ((realpage (save-excursion ad-do-it (point)))
	(secpage (save-excursion (if (re-search-forward "^\\([ \t\f]*\n\\)\\{3,\\}" nil t)
				     (match-end 0)
				   (point-max)))))
    (goto-char (min realpage secpage))
    ))

(defadvice backward-page (around blank-backward-page activate)
  (let ((realpage (save-excursion ad-do-it (point)))
	(secpage (save-excursion
		   (if (re-search-backward "^\\([ \t]*\n\\)\\{3,\\}\\([ \t]*[^ \t\f\n]\\)" nil t)
		       (match-beginning 2)
		     (point-min)))))
    (goto-char (max realpage (if (and secpage (< secpage (point))) secpage 0)))
    ))

;; (ad-deactivate 'backward-page)
;; (ad-activate 'backward-page)
;; (ad-deactivate 'forward-page)
;; (ad-activate 'forward-page)

(when (featurep 'repeatable)
  (repeatable-command-advice backward-page)
  (repeatable-command-advice forward-page) )

;; ;; Flash something in the output window after we execute.
;; ;; This is good for interactive demos.
;; (defadvice py-execute-region (after highwin-advice activate)
;;   (highwin-advice))

;; (defun pylint ()
;;   "Run pylint against the file behind the current buffer after
;;   checking if unsaved buffers should be saved."
;;   (interactive)
;;   (let* ((file (buffer-file-name (current-buffer)))
;; 	 (command (concat "pylint --parseable=y \"" file "\"")))
;;     (save-some-buffers (not compilation-ask-about-save) nil) ; save  files.
;;     (compile-internal command "No more errors or warnings" "pylint")))

(when (featurep 'repeatable)
  (repeatable-substitute-binding 'py-shift-left python-mode-map)
  (repeatable-substitute-binding 'py-shift-right python-mode-map) )


(defun string-rstrip (str)
  "Strips the whitespace at the end of string STR."
  (string-match "[ \t\n]*\\'" str)
  (substring str 0 (match-beginning 0)))

(defun py-find-library (modname)
  "Run a subordinate python to find out where a module is located
and load it in a buffer."
  (interactive ;; "MModule name: ")
   (list (read-string "Module name: "
		      (thing-at-point 'word)
		      )))
  (let* ((program (format "import %s as m; print m.__file__" modname))
	 (filename
	  (replace-regexp-in-string
	   "\\(\\.pyc\\|\\.pyo\\)" ".py"
	   (string-rstrip
	    (shell-command-to-string (format "python -c '%s'" program))))))
    (unless (file-exists-p filename)
      (error (format "File %s could not be found." filename)))
    (find-file filename)
    ))

;; Require my own Python abbreviations.
(require 'python-abbrevs nil t)

(setq info-lookup-alist
      '((symbol
	 (python-mode "[_a-zA-Z0-9]+" nil
		      (("(python-lib)Class-Exception-Object Index"
			nil "^`" nil)
		       ("(python-lib)Function-Method-Variable Index"
			nil "^`" nil)
		       ("(python-lib)Miscellaneous Index"
			nil "^`" nil)
		       ("(python-lib)Module Index"
			nil "^`" nil)
		       ()) nil nil ))))

;; (defun python-fill-paragraph ()
;;   "Fill paragraph normally, except in the case where the cursor
;;   is inside a multiline string, in which case we first isolate
;;   the line, fill, and undo the isolation."
;;
;;   (interactive)
;; ;; FIXME todo
;;   )

(defun python-create-test-script ()
  "Creates a new test script ready for a quick exploration in
  some aspect of the language."
  (interactive)

  (let ((fn (make-temp-name
	     (concat temporary-file-directory "python-find-"))))
    (test-file fn)
    (python-mode)
    (insert "small") (call-interactively 'expand-abbrev)
    ))

;; We want to be able to run this from all modes... a QUICK test script!
(global-set-key* [(control c)(?6)] 'python-create-test-script)

;; Automatically run pdb within emacs
(require 'gud)
(setq gud-pdb-command-name "python -m pdb")


;; Removed on 2015-11-08 to let C-c r be used by compile-register.
;; (when (require 'parenregu nil t)
;;   (define-key* python-mode-map [(control c)(r)] 'paren-regularizer) )


;;------------------------------------------------------------------------------
;; Bazel support.

(add-to-list 'load-path (expand-file-name "~/p/emacs-bazel-mode/lisp"))
(require 'bazel-build nil t)


;;------------------------------------------------------------------------------
;; Support for common build commands (build, lint, test, test-at-point, run).
;; This is intended to work across any file types and build systems.
;; Also, this is in addition to the more general compile command support.

(require 'pytest nil t)
(require 'bazel nil t)
(require 'bazel-build nil t)
(setq bazel-run-commands-from-root t)

(defun compile-is-bazel-workspace ()
  (let ((current (or (buffer-file-name)
                     (and dired-directory (directory-file-name dired-directory)))))
    (message current)
    (bazel-util-workspace-root current)))

(defun compile-default-build ()
  "Default command for build"
  (interactive)
  (let ((compile-command
         (format "cd %s && make %s"
                 (directory-file-name (file-name-directory (buffer-file-name)))
                 (file-name-sans-extension (file-name-nondirectory (buffer-file-name))))))
    (call-interactively 'compile)))

(defun compile-invoke-build ()
  "Invoke a command to build the current package."
  (interactive)
  (if (compile-is-bazel-workspace) (call-interactively #'bazel-build) (compile-default-build)))

(defun compile-invoke-lint ()
  "Invoke a command to build the current package."
  (interactive)
  (if (compile-is-bazel-workspace) (progn) (progn)))

(defun compile-invoke-test ()
  (interactive)
  ;; TODO(blais): Check the type of each file before invocation.
  (if (compile-is-bazel-workspace) (call-interactively #'bazel-test) (pytest-module)))

(defun compile-invoke-test-at-point ()
  (interactive)
  (if (compile-is-bazel-workspace) (call-interactively #'bazel-test-at-point) (pytest-one)))

(defun compile-invoke-run ()
  (interactive)
  (if (compile-is-bazel-workspace) (call-interactively #'bazel-run) (message "Not implemented")))

;; Bind to the C-z and M-g prefixes all the same. C-z is what I'm used to at
;; work; M-g is pretty free for build-related commands and more comfortable to
;; type.
(defun compile-invoke-setup ()
  (dolist (prefix-key '((control z) (meta g)))
    (global-set-key* (vector prefix-key '(c)) 'compile-invoke-build)
    (global-set-key* (vector prefix-key '(l)) 'compile-invoke-lint)
    (global-set-key* (vector prefix-key '(t)) 'compile-invoke-test)
    (global-set-key* (vector prefix-key '(y)) 'compile-invoke-test-at-point)
    (global-set-key* (vector prefix-key '(r)) 'compile-invoke-run)
    ))

(compile-invoke-setup)

;; M-g TAB         move-to-column
;; M-g ESC         Prefix Command
;; M-g c           goto-char
;; M-g e           compile-goto-error
;; M-g f           grep-find
;; M-g g           goto-line
;; M-g n           next-error
;; M-g p           previous-error

;; C-z l           user-python-lint
;; C-z t           user-python-test


;; (defun user-python-get-test-filename (filename)
;;   "Given a filename, obtain the associated test filename."
;;   (if (string-match "_test\.py$" filename)
;;       filename
;;     (concat
;;      (file-name-sans-extension filename)
;;      "_test."
;;      (file-name-extension filename))))

;; (defun user-python-lint ()
;;   "Lint the current file, by some definition of lint."
;;   (interactive)
;;   (cond
;;    ((eq major-mode 'python-mode)
;;     (let ((compile-command (format "sfood-checker %s" (buffer-file-name))))
;;       (call-interactively 'compile)))
;;    ))

;; (defun user-python-test ()
;;   "Test the current file."
;;   (interactive)
;;   (cond
;;    ((eq major-mode 'python-mode)
;;     (let ((compile-command
;;            (format "pytest -s -v %s -k %s"
;;                    (user-python-get-test-filename (buffer-file-name))
;;                    (if current-prefix-arg
;;                        ""
;;                      (cadr (split-string (python-info-current-defun) "\\."))))))
;;       (call-interactively 'compile)))
;;    ))


;;------------------------------------------------------------------------------
;; Support for loading various types of libraries.

(defvar find-lib-alist '((lisp-interaction-mode . find-library)
			 (elisp-mode . find-library)
			 (emacs-lisp-mode . find-library)
			 (python-mode . py-find-library))
  "Association list to select which library finder we'll use.")

(defun find-lib-package ()
  "Find a 'library'; the meaning of that depends on the major
mode, for instance, if you're editing lisp, this will call
'find-library, if you're editing python, this will
'py-find-library, etc."
  (interactive)
  (call-interactively
   (or (cdr (assoc major-mode find-lib-alist)) 'find-file)))

;;(define-key* ctl-x-map [(control h)] 'find-lib-package) -> Given up for ido-imenu, more useful



;;------------------------------------------------------------------------------
;; ReStructuredText / docutils support.
;; For normal text mode support, see section "Standard Packages".

(require 'rst)

;; Make sure we can access ReST bindings everywhere easily.
(define-key* global-map [(control R)] 'rst-minor-mode)

;; Automatically update the TOC when we adjust a section title.
(add-hook 'rst-adjust-hook 'rst-toc-update)

;; Make the top-level decoration a bit farther, I like it like that.
(when (not (fboundp 'cddar)) (defun cddar (x) (cdr (cdr (car x)))))
(setcar (cddar rst-preferred-decorations) 3)


(defun rst-shift-region-right (beg end)
  (interactive "r")
  (rst-shift-region beg end 1))

(defun rst-shift-region-left (beg end)
  (interactive "r")
  (rst-shift-region beg end -1))


(define-key* rst-mode-map [(control c) (control r)] 'rst-shift-region-right)
(define-key* rst-mode-map [(control c) (control l)] 'rst-shift-region-left)



(defun number-range (beg end step)
  "Generate a range of numbers between BEG and END stepping by STEP."
  (let ((num beg)
        rlist)
    (while (< num end)
      (push num rlist)
      (setq num (+ num step)))
    rlist))

(when nil ;; This breaks normal indent... that idiot broke it again.
  (defadvice rst-compute-tabs (around infinite-tabs activate)
    "Extend tabs beyond their maximum value."
    (let ((only-real-tabs ad-do-it))
      (setq ad-return-value
            (append (number-range (+ (car only-real-tabs) rst-indent-width)
                                  fill-column
                                  rst-indent-width)
                    only-real-tabs)))) )

;; Make some of the commands repeatable.
(when (featurep 'repeatable)
  (repeatable-command-advice rst-adjust)
  (repeatable-command-advice rst-backward-section)
  (repeatable-command-advice rst-forward-section)
  (repeatable-command-advice rst-mark-section)
  (repeatable-command-advice rst-shift-region-right)
  (repeatable-command-advice rst-shift-region-left) )

(setq auto-mode-alist
      (append
       (mapcar (lambda (x) (cons x 'rst-mode))
               '("\\.txt$"
                 "\\.rst$" "\\.rest$" "\\.comments$"
                 "\\.asc\\.decrypt$"
                 "TODO$" "README$" "CHANGES$"))
       auto-mode-alist))


;; Set the HTML settings.
(setq rst-compile-toolsets
  `((html . ,(if (eq window-system 'w32)
		 '("rst2html.py" ".htm" "--stylesheet=/docutils.css")
	       '("rst2html.py" ".html" nil)))
    (latex . ("rst2latex" ".tex" nil))
    (newlatex . ("rst2newlatex" ".tex" nil))
    (pseudoxml . ("rst2pseudoxml.py" ".xml" nil))
    (xml . ("rst2xml" ".xml" nil))
    (pdf . ("rst2pdf.py" ".pdf" nil))
    (s5 . ("rst2s5.py" ".xml" nil)))
  )


;; Do not turn on font-lock for rst-mode.
(setq font-lock-global-modes '(not rst-mode))



;; Abbrevs for rst
(defun insert-field-list (typename fieldnames)
  (let* ((col (current-column))
         (pfx (make-string (+ col 2) ?\ )))
    (insert (format "[%s]\n" typename))
    (insert pfx (format ":%s: " (car fieldnames)))
    (let ((p (point)))
      (insert "\n")
      (dolist (name (cdr fieldnames))
        (insert pfx (format ":%s: \n" name))
        )
      (goto-char p))
    ))

(defun text-abbrevs-book ()
  (insert-field-list "book" '("title" "authors" "publisher" "year" "isbn" "comments")))

(defun text-abbrevs-contact ()
  (insert-field-list "addr" '("n" "e" "p")))

(defun text-abbrevs-resto ()
  (insert-field-list "resto" '("name" "location" "type" "desc")))

(define-abbrev-table
  'rst-mode-abbrev-table
  (list
   `("book" "" text-abbrevs-book 0)
   `("addr" "" text-abbrevs-contact 0)
   `("contact" "" text-abbrevs-contact 0)
   ))



;;------------------------------------------------------------------------------
;; Markdown support.

(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

(defun user-markdown-mode-hook ()
  (define-key markdown-mode-map (kbd "TAB") 'markdown-cycle)
  (define-key markdown-mode-map (kbd "M-n") nil)
  (define-key markdown-mode-map (kbd "M-p") nil))
(add-hook 'markdown-mode-hook 'user-markdown-mode-hook)



;;------------------------------------------------------------------------------
;; SQL support.

;; Connection settings for project flair with an ssh tunnel.
(require 'sql)
(setq sql-postgres-options
      (append sql-postgres-options '("-p" "5433")))

;; There appears to be a bug: when you create a new SQLi buffer, it should set
;; the global value of sql-buffer to it, but it doesn't. It looks like it's
;; setting only the buffer-local value. Fix this with an advice.
(defadvice sql-product-interactive (after fix-sql-buffer-as-global activate)
  (setq-default sql-buffer (get-buffer "*SQL*")))


; (setq sql-postgres-options '("-P" "pager=off" "-p" "5433"))

;; (defun user-sql-mode-hook ()
;;   (make-local-variable 'comint-output-filter-functions)
;;   (setq comint-output-filter-functions
;;      (append comint-output-filter-functions '(comint-insert-header))))
;; (add-hook 'sql-mode-hook 'user-sql-mode-hook)
;;
;; (defun comint-insert-header (&optional string)
;;   "Insert a newline in the output. This is used to fix a bug in
;; sql-mode wherein the output is concatenated to the last prompt."
;;   (interactive)
;;   (let ((pmark (process-mark (get-buffer-process (current-buffer)))))
;;     (save-excursion
;;       (condition-case nil
;;        (goto-char
;;         (if (interactive-p) comint-last-input-end comint-last-output-start))
;;      (error nil))
;;       (insert "\n")
;;       )))


;; Add a key binding that can pretty-format an SQL statement in any language.
(when (require 'sql-transform nil t)
  (define-key* ctl-x-map [(meta q)] 'sql-rewrite))



;;------------------------------------------------------------------------------
;; browse-url

;;(setq browse-url-browser-function 'browse-url-kde)
;;(setq browse-url-browser-function 'browse-url-firefox)

;; Use Google Chrome to browse files.
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "google-chrome")

(defvar browse-dictionary-dictionaries
  '("http://answers.com/%s")
  ;;'("http://onelook.com/?w=%s")
  "List of online dictionaries to lookup when looking up a word from emacs.")

(defun browse-dictionary-lookup-word (start end)
  "Find the highlighted word on the web in the dictionary, in a
   web browser."
  (interactive "r")
  (dolist (x browse-dictionary-dictionaries)
    (browse-url (format x (buffer-substring start end)))))

(defun browse-dictionary-insert (term)
  "Insert the term from the dictionary at point."
  (interactive "MLookup dictionary: ")
  (setenv "TERM" "vt100")
  (let ((output)
        (temp-buffer-show-function (lambda (b))) ;; Don't display buffer.
        )
    (with-output-to-temp-buffer "*dictionary*"
      (with-current-buffer standard-output
        (call-process "links" nil t t "-dump" (format "http://mobile.answers.com/%s" term))
        (beginning-of-buffer)
        (re-search-forward "^   .*(.*)")
        (beginning-of-line)
        (let ((begin (point)))
          (re-search-forward "^[ \t]+_____")
          (beginning-of-line)
          (setq output (buffer-substring begin (point))))
        ))
    (save-excursion
      (insert ":" term "\n" output))
    ))
;(global-set-key* [(control c)(i)] 'browse-dictionary-insert)
(global-set-key* [(control x)(meta b)] 'browse-url-at-point)


;;------------------------------------------------------------------------------
;; google-define

;; (require 'google-define)
;; (global-set-key* [(control c)(i)] 'google-define)


;;------------------------------------------------------------------------------
;; golang-mode

(when (require 'go-mode nil t)
  (require 'go-guru nil t)
  (add-hook 'go-mode-hook #'go-guru-hl-identifier-mode)
  )


;;------------------------------------------------------------------------------
;; w3 and w3m

;; (let ((fun (lookup-key global-map [(meta n)])))
;;   (dolist (map (list w3m-lynx-like-map w3m-info-like-map))
;;        (define-key* map [(meta n)] fun)))


;;------------------------------------------------------------------------------
;; trac-wiki

;; (unless (eq window-system 'w32)
;;   (require 'trac-wiki)
;;   (setq trac-projects
;;      '(("site"
;;         :endpoint "http://server/trac/login/xmlrpc"
;;         :login "user"
;;         )))
;;   )


;;------------------------------------------------------------------------------
;; Scheme support
;; scheme-mode, Quack, Geiser

(defvar user-geiser-root (concat (getenv "HOME") "/src/elisp/geiser"))

(when (file-exists-p user-geiser-root)
  ;; Note: the load-path setup is done automatically in geisel.el,
  ;; which is really clean.
  (load (concat user-geiser-root "/elisp/geiser.el"))

  ;; Restrict the valid implementations (not needed, use run-racket).
  ;;(setq geiser-active-implementations '(racket))

  (define-abbrev-table
    'scheme-mode-abbrev-table
    `( ("script" "#!/usr/bin/env racket\n#lang racket/base\n")
       ("racket" "#!/usr/bin/env racket\n#lang racket/base\n") ))

  ;;------------------------------------------------------------------------------
  ;; Quack support
  (require 'quack)

  ;; Don't override my find-file command you Quack.
  (define-key scheme-mode-map [(control x)(control f)] nil)
  )

;; (add-to-list 'auto-mode-alist
;;              '("\\.\\(sim\\|ss\\|scm\\|sl\\)$" . scheme-mode) )

;; [2011-04-03] Use this for Scheme programming.
;; (require 'quack) ;; From emacs-goodies in Ubuntu.


;;------------------------------------------------------------------------------
;; sml-mode

;; (add-to-list 'auto-mode-alist '("\\.sml$" . sml-mode) )
;;(autoload 'sml-mode "sml-mode" "Major mode for editing SML." t)
;;(autoload 'sml-shell "sml-mode" "Run an SML sub-process" t)


;;------------------------------------------------------------------------------
;; eiffel-mode

;; (add-to-list 'auto-mode-alist '("\\.e$" . eiffel-mode) )
;;(autoload 'eiffel-mode "eiffel.el" "Major mode for editing Eiffel" t)


;;------------------------------------------------------------------------------
;; prolog-mode

;;(autoload 'run-prolog "prolog-mode" "Run a Prolog sub-process." t)
;;(autoload 'prolog-mode "prolog-mode" "Major mode for editing prolog" t)



;;------------------------------------------------------------------------------
;; print buffer-file-name

(global-set-key* [(control x)(w)] (lambda () (interactive)
				   (message (buffer-file-name))))

(when (equal (getenv "SITE") "home")
  (global-set-key* [(control c)(I)] (lambda () (interactive)
				      (insert (buffer-file-name)))))


;; (global-set-key* [(control c)(?`)]
;;                      (lambda ()
;;                        (interactive)
;;                        (insert (buffer-file-name))
;;                     (search-backward "conf")
;;                     (backward-kill-sexp)
;;                     ))


;;------------------------------------------------------------------------------
;; Jam/MR

(when (require 'jam-mode nil t)
  (add-to-list 'auto-mode-alist (cons "^Jam\\(file\\|rules\\)$" 'jam-mode)) )


;;------------------------------------------------------------------------------
;; css editing support

(autoload 'css-mode "css-mode")
(setq cssm-mirror-mode nil)
(add-to-list 'auto-mode-alist (cons "\\.css\\'" 'css-mode))
(add-to-list 'auto-mode-alist (cons "\\.css.m4\\'" 'css-mode))

;;
;; works only if call-process-shell-command is defined
;;
(if (and (fboundp 'filter) (fboundp 'call-process-shell-command))
    (progn
      (defun css-m4-save-hook ()
        (let* ((bufname (buffer-file-name))
               (outname (substring bufname 0 -3))
               (cmd (format "m4 %s > %s" bufname outname)))
          (call-process-shell-command cmd))))

  (defun css-m4-mode-hook ()
    (interactive)
    (let* ((bufname (buffer-file-name))
           (outname (substring bufname 0 -3))
           (cmd (format "m4 %s > %s" bufname outname)))
      (setq compile-command cmd)
      (or (fboundp 'filter)
          (add-hook 'after-save-hook 'css-m4-save-hook))
      ))

  (add-hook 'css-mode-hook 'css-m4-mode-hook)
  )




;;------------------------------------------------------------------------------
;; swap function

(defun random-string (len)
  "Returns a random string of the given length."
  (apply 'concat
         (let (i l)
           (dotimes (i len)
             (setq l (append (list (char-to-string (+ (random 26) 97))) l)))
           l)))

;; (defun swap-strings (point mark from to)
;;   "Swaps two strings in the specified region. With prefix argument, query."
;;   ;; Written by Martin Blais.
;;   (interactive "r\nsFrom: \nsTo: ")
;;   (let ((rs (random-string 16)) ;; this many chars should be unique.
;;      (repl-fun (if current-prefix-arg 'query-replace 'replace-string))
;;      (m1 (set-marker (make-marker) point))
;;      (m2 (set-marker (make-marker) mark))
;;      )
;;     (save-excursion
;;      (funcall repl-fun from rs nil m1 m2)
;;      (funcall repl-fun to from nil m1 m2)
;;      (replace-string rs to nil m1 m2)
;;     )))

;; (This is contributed from Stefan Monnier, 2003-10-30, after he saw my
;; swap-strings above).
(defun swap-strings (str1 str2)
  "Swaps two strings."
  (interactive "sString 1: \nsString 2: ")
  (query-replace-regexp-eval
   (concat (regexp-quote str1) "\\|" (regexp-quote str2))
   '(if (equal (match-string 0) str1) str2 str1) ))
(defalias 'strings-swap 'swap-strings)

;; (search-forward-regexp (concat (regexp-quote str1) "\\|" (regexp-quote str2)))
;; (replace-match (if (equal (match-string 0) str1) str2 str1))

;; (defun swap-regexps (re1 str1 re2 str2)
;;   "Swaps two strings."
;;   (interactive "sRegexp 1: \nsString 1: \nsRegexp 2: \nsString 2: ")
;;   (query-replace-regexp-eval
;;    (concat re1 "\\|" re2)
;; FIXME: how do I find out which of the regexps matched?
;;    '(if (equal (match-string 0) str1) str2 str1) ))

;; (global-set-key* [(control shift meta s)] 'swap-strings)


;;------------------------------------------------------------------------------
;; Renaming variants of multi-word programming field names.

(defun string-replace-variants (from to)
  "Given a series of words with spaces in-between, replace all
  variants of the words as variables, e.g. 'video rating tier' to
  'video product type' will replace VIDEO_RATING_TIER to
  VIDEO_PRODUCT_TYPE, video_rating_tier to video_product_type,
  and VideoRatingTier to VideoProductType, and perhaps a few
  more."

  (interactive "sString 1: \nsString 2: ")
  (let ((lfrom (split-string from))
        (lto (split-string to)))
    (let* ((replacements (list (cons (mapconcat 'capitalize lfrom "")
                                     (mapconcat 'capitalize lto ""))
                               (cons (mapconcat 'upcase lfrom "_")
                                     (mapconcat 'upcase lto "_"))
                               (cons (mapconcat 'downcase lfrom "_")
                                     (mapconcat 'downcase lto "_")))))

      ;; Note: I can't seem to get dynamic binding to refer directly to
      ;; 'replacements. Don't quite get why this isn't found yet. TBD.
      (setq string-replace-variants-replacements replacements)

      (query-replace-regexp-eval
       (mapconcat 'regexp-quote (mapcar 'car replacements) "\\|")
       '(cdr (assoc (match-string-no-properties 0) string-replace-variants-replacements)))
      )))

(defalias 'qrv 'string-replace-variants)


;;------------------------------------------------------------------------------
;; Interleaving lines in two regions.

(defun interleave-lines (beg end)
  "Set point and mark, and all the lines in the region will be interleaved
with all the lines between mark + (mark - point)."
  (interactive "r")
  (let* ((lbeg (line-number-at-pos beg))
	 (lend (line-number-at-pos end))
	 (l lbeg))
    (while (< l lend)
      (save-excursion
	(goto-line lend)
	(kill-line)
	(incf l)
	(goto-line l)
	(yank)
	(incf l)
	(incf lend)
	))
   ))


;;------------------------------------------------------------------------------
;; Offsetting numbers by a specific number

(defun query-replace-numbers-offset (offset)
  "Applies an offset to integers found in the buffer."
  (interactive "nOffset: ")
  (query-replace-regexp-eval
   "[0-9]+"
   '(+ (string-to-int (match-string 0)) offset)))



;;------------------------------------------------------------------------------
;; Reverse the characters in the given region

(defun reverse-region-chars (beg end)
  (interactive "r")
  (let ((b beg)
        (e (- end 1)))
    (while (< b e)
      (transpose-regions b (+ b 1) e (+ e 1))
      (setq b (+ b 1)
            e (- e 1))
      ))
  )

;;------------------------------------------------------------------------------
;; gettext / translation

;; (require 'po-mode)
;; (setq auto-mode-alist (cons '("\\.po[tx]?\\'\\|\\.po\\." . po-mode) auto-mode-alist))
;;; (autoload 'po-find-file-coding-system "po-mode")
;;; (modify-coding-system-alist 'file "\\.po[tx]?\\'\\|\\.po\\."
;;;                          'po-find-file-coding-system)


;;------------------------------------------------------------------------------
;; Apache configuration files.

(autoload 'apache-mode "apache-mode" "autoloaded" t)
;; To be set by hand in the file local variables.
;; (add-to-list 'auto-mode-alist '("\\.htaccess$"   . apache-mode))
;; (add-to-list 'auto-mode-alist '("httpd\\.conf$"  . apache-mode))
;; (add-to-list 'auto-mode-alist '("apache2\\.conf$"  . apache-mode))
;; (add-to-list 'auto-mode-alist '("commonapache2\\.conf$"  . apache-mode))
;; (add-to-list 'auto-mode-alist '("srm\\.conf$"    . apache-mode))
;; (add-to-list 'auto-mode-alist '("access\\.conf$" . apache-mode))

;;------------------------------------------------------------------------------
;; Support for editing the results of the grep command.

(autoload 'all "all" "Edit all lines matching a given regexp.")
(require 'grep-edit nil t)
(require 'grep nil t)

(when (boundp 'grep-host-defaults-alist)
  (grep-compute-defaults)

  ;; Fancier version of the grep-find command that looks into Python files, for
  ;; localhost.
  (setcdr (assq 'grep-find-command
                (cdr (assq 'localhost grep-host-defaults-alist)))
          (list (concat
                 "find . -name .svn -prune -o -name .hg "
                 "-prune -o -type f -regex '.*\\.\\(py\\|txt\\|h\\|cpp\\|java\\)' -print0 | "
                 ;;"-prune -o -type f -regex '.*\\.\\(py\\|txt\\|h\\|hpp\\|cpp\\|H\\|C\\)' -print0 | "
                 "xargs -0" (if (not (eq window-system 'mac)) " -e" "")
                 " grep -nHi -e ")))
  )



;; Support for grepping the filesystem. ('grep-find' is in the stdlib.)
(define-key* goto-map [(f)] 'grep-find) ;; Tentative
(global-set-key* [(control c)(f)] 'grep-find) ;; FIXME: Remove this eventually



;;------------------------------------------------------------------------------
;; highlight beyond fill column

(unless (eq window-system nil) ;; This requires graphics for the fringe

  (when (require 'highlight-beyond-fill-column nil t)
    ;; 'underline 'trailing-whitespace 'region 'secondary-selection 'fringe
    (defvar highlight-beyond-fill-column-face-default 'underline)

    (setq highlight-beyond-fill-column-face
	  highlight-beyond-fill-column-face-default)

    ;; Temporarily remove this, I never actually like to use it by default.
    ;; (setq highlight-beyond-fill-column-in-modes
    ;;       (append highlight-beyond-fill-column-in-modes
    ;;               '(text-mode c-mode c++-mode)))

    (defun highlight-beyond-fill-column-toggle ()
      "Disable highlighting of lines beyond fill column."
      (interactive)
      ;; Do not make the variable local, we want to disable highlighting for all
      ;; buffers, leaving the new value as the default.
      (setq highlight-beyond-fill-column-face
	    (if (eq highlight-beyond-fill-column-face nil)
		highlight-beyond-fill-column-face-default
	      nil))
      (font-lock-ensure) )

    (define-key* ctl-x-map [(control h)] 'highlight-beyond-fill-column-toggle)
    ))


(defun font-lock-setup-width-warning (width)
  "Make text beyond column WIDTH appear in `font-lock-warning-face'."
  (require 'font-lock)
  (font-lock-mode 1)
  (make-local-variable 'font-lock-keywords)
  (font-lock-add-keywords nil `((,(format "^.\\{%d\\}\\(.+\\)" width)
                                 1 font-lock-warning-face t))))

(dolist (hook '(c++-mode-hook python-mode-hook))
  (add-hook hook '(lambda () (font-lock-setup-width-warning 92))))


;;------------------------------------------------------------------------------
;; blink/highlight the current window

(when nil
  ;; Disabled temporarily, want to try to live without for a bit [2013-04-05]

(when (require 'highwin nil t)
  (defadvice other-window-all-frames (after highwin-advice activate)
    (highwin-advice)) )
)

;; (global-hl-line-mode)  ;; toggle

;; Note: handle-switch-frame only notifies between emacs' frames, not all
;; other windows.
;;
;; (defadvice make-frame-visible (after highwin-frame-advice activate)
;;   (message "SWITCHED"))
;;   (highwin-advice))
;;
;; (defadvice select-frame-set-input-focus (before test activate)
;;   (message "SWITCHED"))


;;------------------------------------------------------------------------------
;; highlight the current line

(autoload 'highlight-current-line "highlight-current-line")

(defface highlight-current-line-face
  '((t (:background "#fafaf0")))
    "Face used to highlight current line.")

;(require 'highline) ; Never tried?


;;------------------------------------------------------------------------------
;; xxdiff support.

;; FIXME: make this section conditional on import working, autoload
(when (require 'xxdiff nil t)

  (define-key* vc-prefix-map [(backspace)] 'xxdiff-diff-buffer-and-file)
  ;;(define-key* vc-prefix-map [(?+)] 'xxdiff-svn-diff)
  (define-key* vc-prefix-map [(?\()] 'xxdiff-compare-selections)
  (define-key* vc-prefix-map [(?\))] 'xxdiff-compare-kill-ring)

  (require 'log-view)
  (define-key* log-view-mode-map [(?+)] 'xxdiff-log-view-diff-changeset)

  (require 'xxdiff-style nil t)
  )


;; (substitute-key-definition 'vc-diff 'vc-diff-xxdiff vc-prefix-map)

;;------------------------------------------------------------------------------
;; tmuxdiff support.

(defvar tmuxdiff-exec "tmuxdiff"
  "The tmuxdiff executable to run.")

(defun tmuxdiff-compare-kill-ring ()
  "Spawn an tmuxdiff to compare the last two entries on the
kill-ring.  With prefix arg, compare the last three."
  (interactive)

  (let* ((idx (if mark-active -1 0))
	 (selections (list (current-kill (+ idx 1) t)
			   (if (= idx 0)
			       (current-kill idx t)
			     (buffer-substring (region-beginning) (region-end)))))
	 files)
    (when current-prefix-arg
      (setq selections (append (list (current-kill (+ idx 2) t)) selections))
      ;;(setcdr selections (cons (current-kill 2 t) (cdr selections)))
      )

    (setq files (mapcar
		 (lambda (sel) (let ((fn (make-temp-file "tmuxdiff-emacs.")))
				 (with-temp-file fn (insert sel))
				 fn))
		 selections))

    (let ((args (append (list tmuxdiff-exec nil nil nil) files)))
      (apply 'call-process args)
      )
    (dolist (fn files)
      (when (file-exists-p fn) (delete-file fn)))
    ))

;; (define-key* vc-prefix-map [(backspace)] 'xxdiff-diff-buffer-and-file)
;; (define-key* vc-prefix-map [(?+)] 'xxdiff-svn-diff)
;; (define-key* vc-prefix-map [(?9)] 'tmuxdiff-compare-selections)
(define-key* vc-prefix-map [(?0)] 'tmuxdiff-compare-kill-ring)



;;------------------------------------------------------------------------------

;; (defun unbearably-lightly-levitate (&optional exit-char message)
;; See highwin.el for the latest definition.


;;------------------------------------------------------------------------------
;; GraphViz/dot mode

;;(require 'graphviz-dot-mode nil t)


;;------------------------------------------------------------------------------
;; Support for browsing the kill-ring

(require 'browse-kill-ring nil t)


;;------------------------------------------------------------------------------
;; Windows transposition code
;; (Scavenged from http://arthur.acm.jhu.edu/code/emacs)

(defun swap-windows (arg)
  "Switch the buffers shown in the current window and the next."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

(defun transpose-windows ()
  "If there are only two windows, switch between vertical and
horizontal split."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                        (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                        (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(define-key* ctl-x-4-map (kbd "t") 'transpose-windows)
(define-key* ctl-x-4-map (kbd "y") 'swap-windows)
;(define-key* ctl-x-map [(r) (4)] 'transpose-windows)
;(define-key* ctl-x-map (kbd "y") 'transpose-windows)

(global-set-key* [(control c)(?{)] 'swap-windows)
(global-set-key* [(control c)(?})] 'swap-windows) ;; For now, no difference.


;;--------------------------------------------------------------------------------
;; Helm - Incremental completion and selection narrowing framework

(when (and (>= emacs-major-version 24) (>= emacs-minor-version 3))
  (when (require 'helm-config nil t)
    ;;(helm-mode 1)
    (require 'helm-swoop nil t)

    ;; When doing isearch, hand the word over to helm-swoop
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    ;; (global-set-key (kbd "M-i") 'helm-swoop)
    ;; (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
    ))

;;--------------------------------------------------------------------------------
;; Protocol buffers.

;; If a .txt or .config file begins with a line that ends with { or <, open it
;; automatically in protobuffer mode. This should account for most of those
;; files.

(if (equal (getenv "SITE") "google")
    (progn
      (add-to-list 'auto-mode-alist
                   '("\\.\\(pb\\|.asciipb\\|proto\\.txt\\|pbtxt\\)$" . protobuffer-mode))
      (when (boundp 'magic-mode-alist)
        (add-to-list 'magic-mode-alist
                     (cons (concat "\\(^\\s-*\\(#.*\\|\\)\n\\)*^\\(syntax = \\|import \\|package \\)") 'protobuffer-mode))) )
  (progn
    (when (require 'pbascii nil t)
      (add-to-list 'auto-mode-alist
                   '("\\.\\(pb\\|.asciipb\\|proto\\.txt\\|pbtxt\\)$" . pbascii-mode))
      (when (boundp 'magic-mode-alist)
        (add-to-list 'magic-mode-alist
                     (cons (concat "\\(^\\s-*\\(#.*\\|\\)\n\\)*"
                                   "[a-z_]+\\( {\\|: \\(<\\|[0-9]+\\|\".*\"\\)\\)\\s-*$") 'pbascii-mode)))
      )))



;;;; ==========================================================================
;;;; *
;;;; *  Mail and News
;;;; *
;;;; ==========================================================================

;; -*- mode: lisp-interaction -*-
;;
;; my settings for sending email with more convenience.
;;

(require 'sendmail)

(when (>= emacs-major-version 24)
  (setq send-mail-function 'sendmail-send-it))

;; remove annoying startup warning.
(setq compose-mail-user-agent-warnings nil)


;;------------------------------------------------------------------------------
;; on the mac, make sure the method is appropriate.

(when (eq window-system 'mac)
  (setq send-mail-function 'sendmail-send-it))


;;------------------------------------------------------------------------------
;; mail aliases

;; enable automatic abbrevs expansion in headers area.
;;(add-hook 'mail-setup-hook 'mail-abbrevs-setup)

;; FIXME: TODO - Call "addr"

;;------------------------------------------------------------------------------
;; message mode setup

;; emails should be pretty tight horizontally, it looks better in many webmail
;; interfaces.
(defvar mail-fill-column 70
  "fill column for email composition.")

(defun user-message-mode-hook ()
  ;; Adjust the fill column tight for messages.
  (setq fill-column mail-fill-column)

  (define-key* message-mode-map [remap next-line] 'mail-abbrev-next-line)
  (define-key* message-mode-map [remap end-of-buffer] 'mail-abbrev-end-of-buffer)
  ;; (define-key* message-mode-map [remap mail-yank-original] 'mail-yank-x-selection)

  ;; Remove an unforunate key binding from message mode.
  (define-key* message-mode-map [(meta n)] nil)

  ;; Note: this override mail-fill-yanked-message, but we don't really plan to use
  ;; it on top of this.
  (define-key* message-mode-map [(control c)(control q)] 'mail-do-indent)

  (abbrev-mode -1)

  ;; if according to the fields the email has already been sent, set
  ;; mail-sent-count appropriately.
  (save-excursion
    (beginning-of-buffer)
    (let ((end (re-search-forward "^--text follows this line--" nil t)))
      (when end
	(beginning-of-buffer)
	(when (re-search-forward "^sent:" end t)
	  (setq mail-sent-count (incf mail-sent-count))))))

    ;; make it a little more difficult to delete a buffer with an unsent email.
    (make-local-variable 'kill-buffer-hook)
    (add-hook 'kill-buffer-hook
	      (lambda ()
		(unless (or (> mail-sent-count 0)
			    (y-or-n-p "mail not sent; really kill buffer? "))
		  (error "not killing buffer."))))
  )

;; expand aliases on movement out of the relevant fields.
(add-hook 'message-mode-hook 'user-message-mode-hook)


;; mark a message as having been sent.
(defvar mail-sent-count 0
  "a buffer-local variable that is set to the number of times a mail has been sent.")
(make-variable-buffer-local 'mail-sent-count)


(defun mark-mail-as-sent ()
  ;; increment the number of sent emails.
  (setq mail-sent-count (incf mail-sent-count))

  ;; insert a "sent" header.
  (save-excursion
    (beginning-of-buffer)
    (when (re-search-forward "^--text follows this line--" nil t)
      (beginning-of-line)
      (insert "sent: 1\n"))
    ))



;; save a local copy of every email being sent. this is a safeguard in case we
;; lose email with the sent queue (it happened once before, once was enough).

(defvar mail-local-copy-dir (concat home "/mail/localsent")
  "a directory to place copies of sent emails.")

(defun create-local-copy ()
  "save a local copy of the mail buffer to a file."
  (let* ((fn (time-stamp-string "localsent.%04y-%02m-%02d.%02h%02m%02s.msg"))
	 (fullfn (concat mail-local-copy-dir "/" fn))
	 (contents (buffer-string)))
    (unless (file-exists-p mail-local-copy-dir)
      (error (format "local sent directory does not exist: %s" mail-local-copy-dir)))
    (write-file fullfn)))


;; note: we need to mark the mail buffer as sent before we save the local copy.
;; hooks are inserted at the front, so these are reversed.
(add-hook 'mail-send-hook 'create-local-copy)
(add-hook 'mail-send-hook 'mark-mail-as-sent)


;;------------------------------------------------------------------------------
;; make sure that i always send a copy to my email server for backups, i've had
;; enough lost email before: out-of-date password and then lost mail from the
;; queue somehow, postfix broken problems and sendmail fails silently, and it's
;; difficult to access the messages in the postfix queue to resend. this ensures
;; that at least there is a copy somewhere.

;; Don't Cc to yourself by default -- in other sites it may not be welcome.
;; place it in the site-specific file.
;;;;(setq mail-self-blind t)

(when nil

(defvar user-self-blind-mail-address "blais+sent_items@furius.ca"
  "email address to send self-blind bcc to.")

(defadvice mail-setup (around mail-modify-self-blind-email activate)
  (let ((user-mail-address user-self-blind-mail-address))
    ad-do-it))

)


;;------------------------------------------------------------------------------
;; support for new message mode.

(require 'message)

(setq message-confirm-send t)

;; FIXME: Removed as above
;;;; (setq message-default-mail-headers (replace-regexp-in-string
;;;; 				    user-mail-address user-self-blind-mail-address
;;;; 				    message-default-mail-headers )



;; we could add some more headers in here for filtering.
;;(setq mail-default-headers nil)
;;(setq mail-default-headers "x-blais-sent: true\n")


;;------------------------------------------------------------------------------
;; customize my from address (we need to do this because of the self-blind copy
;; address interaction with this).

(setq mail-setup-with-from t
      mail-from-style 'angles)

;; define a custom from field address.
(defvar user-from-mail-address user-mail-address
  "email address to use for from: field.")

(defadvice mail-insert-from-field (around make-sure-from-is-not-blind activate)
  (let ((user-mail-address user-from-mail-address))
    ad-do-it))


;;------------------------------------------------------------------------------
;; some settings to automatically figure out the list of encryption targets.

;; define an advice to remove the part of usernames after a plus sign. this is
;; used by the encryption to figure out the list of recipients automatically.
(defun remove-after-plus (email)
  "remove the part after the plus sign an email address username, e.g.
  user+sent_items@domain.com becomes user@domain.com"
  (let* ((comps (mc-split "@" email))
	 (username (car comps)))
    (print comps)
    (when (string-match "\\+.*" username)
      (setq username (substring username 0 (match-beginning 0))))
    (mapconcat 'identity
	       (append (list username) (cdr comps)) "@")))

(defadvice mc-strip-addresses (after strip-after-plus-sign activate)
  (setq ad-return-value
	(mapconcat 'remove-after-plus
		   (mc-split ", " ad-return-value) ", ")))

;;------------------------------------------------------------------------------
;; sometimes a recipient's email address is not present in the user's gpg public
;; key ring, despite the actual person having a key there (under another
;; identity). when such an identity is missing, we want to translate the
;; recipient's email address to the corresponding email address which is present
;; in the keyring (asking people to update their identity is not good enough...
;; people are slow and resilient to change). this code defines an after advice
;; on mc-strip-addresses, which is only used in the mailcrypt code at that
;; point, so it's kosher.

(defvar encryption-recipient-substitution-alist nil
  "an alist used to translate recipient email addresses to their
  corresponding encryption identity key email addresses. you need
  this is a user's destination email does not have a
  corresponding identity in your public keyring.")

(defadvice mc-strip-addresses (after substitute-emails activate)
  (setq ad-return-value
	(mapconcat (lambda (addr)
		     (or (cdr (assoc (remove-after-plus addr)
				     encryption-recipient-substitution-alist))
			 addr))
		   (mc-split ", " ad-return-value) ", ")))


;;------------------------------------------------------------------------------
;; make sure to always automatically encrypt for myself.

(setq mc-encrypt-for-me t)

;;------------------------------------------------------------------------------
;; Do not sign outgoing email by default.

(setq mc-pgp-always-sign 'never) ;; nil means 'ask



;;------------------------------------------------------------------------------
;; Automatically paste and quote the X selection instead of the rmail support.

(defun mail-yank-x-selection (arg)
  "Insert the X selection as a reply.
See mail-yank-original for more details."
  (interactive "P")
  (let ((sel (x-get-selection nil 'STRING)))

    (when sel
      (set-text-properties 0 (length sel) nil sel)
      (let ((start (point)))
	(goto-char (mail-text-start))
	(push-mark)
	(insert sel)
;;	(sc-cite-original)
	))))

;; (defalias 'mail-yank-original 'mail-yank-x-selection)

;; Create a new function to manually indent the body of the email.
(defun mail-do-indent ()
  (interactive)
  (save-excursion
    (goto-char (mail-text-start))
    (push-mark)
    (goto-char (point-max))
    (mail-indent-citation)
    (pop-mark)))

(setq mail-yank-prefix "> ")




;;------------------------------------------------------------------------------
;; Cite replies with Supercite!

;; (autoload 'sc-cite-original "supercite" "Supercite 3.1" t)
;; ;; (autoload 'sc-submit-bug-report "supercite" "Supercite 3.1" t)
;;
;; ;; Install supercise.
;; (add-hook 'mail-citation-hook 'sc-cite-original)
;;
;; (setq sc-citation-delimiter-regexp "[>:]+")
;;
;; (setq news-reply-header-hook nil)
;; (setq sc-citation-leader " ")
;; (setq sc-preferred-attribution-list
;;         '("sc-lastchoice" "x-attribution" "sc-consult" "initials" "firstname"
;;           "lastname"))
;;
;; (setq sc-attrib-selection-list nil)
;; (setq sc-attrib-selection-list
;;       '(("from" (("pattern" . "nickname")
;;                  ))))
;;

;;------------------------------------------------------------------------------
;; Automatically encrypt emails which have matching targets in my public key.
;; (I should not have to figure out if the email needs to be encrypted.)

;; FIXME: TODO -- the 'automatic' part needs to be implemented. Not sure if this
;; is worth it.

;;------------------------------------------------------------------------------
;; Support for composing multiple emails concurrently. The drafts need to be
;; saved to a temporary file.

;; Automatically recognize files with emails in them.
(when (boundp 'magic-mode-alist)
  (add-to-list 'magic-mode-alist `("^\\(From\\|To\\):" . message-mode)))


;;------------------------------------------------------------------------------
;; completion from mail addresses found in text files

;; FIXME: merge 'find-emails' into 'addr' to get the full list of emails.
(defun expand-emails-get-emails ()
  "Looks for email addresses in a corpus of text files, using a
subprocess, and completes an email address based on the results
of this search."
  (split-string
   (call-process-get-output "find-emails" nil nil "find-emails" (format "%s/priv" user-projects-root)) ))

;; FIXME: I'm sure Emacs has a simpler built-in way to do this-- find it and replace by it.
(defun call-process-get-output (program &optional infile bufname &rest args)
  "Calls a process and returns a string with the output of that
process. Attempts to get rid of the buffer afterwards."
  (let* ((bufname (or bufname "*call-process-get-output*"))
         (buf (get-buffer-create bufname))
         output prepoint)
    (save-excursion
      (set-buffer buf)
      (setq prepoint (point))
      (print (append (list program infile bufname) args))
      (apply
       'call-process (append (list program infile bufname) args))
      (setq output (buffer-substring prepoint (point-max)))
      (kill-buffer buf)
      )
    output))


(defun addr ()
  (interactive)
  (insert (completing-read "Email: " (expand-emails-get-emails) nil t)))

;;------------------------------------------------------------------------------
;; Jupyter notebooks (via emacs-jupyter)

(add-to-list 'load-path "/home/blais/src/github/nnicandro/emacs-jupyter")
(require 'jupyter nil t)




;;;; ==========================================================================
;;;; *
;;;; *  Server
;;;; *
;;;; ==========================================================================

(require 'server)

;; (defadvice server-start (around server-named-start activate)
;;   "If called interactively, ask for the server name before running it."
;;   (when (interactive-p)
;;     (setq server-name
;; 	    (completing-read "Server Socket Name: "
;; 			     '("secondary" "server") nil nil "secondary")))

;;   ad-do-it)

;; Kill the buffer that we're exiting when we're done.
(when (equal (getenv "SITE") "home") ;; For minimal config.
  (add-hook 'server-done-hook
	    (lambda () (kill-buffer (current-buffer)))))

;; Pour eviter prompt quand on a deja buffer du meme nom.
(setq server-temp-file-regexp
      "^/tmp/\\|/.article$\\|/.letter$\\|/mail/drafts/")

;; Useful binding for server-edit.
;;(global-set-key* [(meta s)] 'server-edit)


;; Function to finish emacsclient edit, when we're using multiple frames.
;; C-x C-c : Vire le frame et kill le buffer et termine emacsclient.
(defun delete-frame-and-inform-client ()
  "If some client was waiting, inform him he can leave. Then delete the frame."
  (interactive)
  (let* ((buffer (current-buffer))
	 (frame (window-frame (selected-window))))
    (if server-buffer-clients
	(server-edit)
      (delete-frame frame))
    (if (and (not (get-buffer-window buffer 't))
	     (buffer-name buffer))
	(kill-buffer buffer))))

(defun gnuserv-already-running-p ()
  "Returns non-nil if an emacsserver is already running on this host."
  (let ((port nil)
	(gnu_port_env (getenv "GNU_PORT"))
	(default-port 21490))
    (setq port (if gnu_port_env
		   (string-bto-number gnu_port_env)
		 (+ default-port (user-uid))))
    ;; FIXME how do we additionally check /etc/protocols (i.e. getservbyname())
    (condition-case nil
	(let ((p (open-network-stream "server-check" nil "localhost" port)))
	  ;;(delete-process p)
	  t)
      (error nil))))

(defun get-tmux-session ()
  "Return the unique id of the current tmux session (a string)."
  (let ((tmux (getenv "TMUX")))
    (when tmux
      (string-match ".*,\\([0-9]+\\)$" tmux)
      (match-string 1 tmux) )))

;; Start the server if requested.
(unless (eq window-system 'w32)
  (let ((warning-minimum-log-level :error)) ;; Disable the warning.
    (let ((tmux-session (get-tmux-session)))
      (when tmux-session (setq server-name (concat "server" tmux-session))))
    (server-start)) )



;;--------------------------------------------------------------------------------
;; Server for editing files with Chrome

(when nil
  (progn
    (require 'edit-server)
    (edit-server-start)) )







;;;; ==========================================================================
;;;; *
;;;; *  Window System
;;;; *
;;;; ==========================================================================

(when (eq window-system nil) ;; Console

  (custom-set-variables
   '(frame-background-mode (quote dark))
   )


;;   ;; Set a comment face because it's missing by default.
;;   (custom-set-faces
;;    '(font-lock-comment-face ((((class color) (min-colors 8) (background dark))
;; 			      (:foreground "yellow")))))

  (setq items-dark-console-256
        '((class color) (min-colors 256) (background dark)))

  (custom-set-faces
   ;; Make the window separator without a background color, more sparse, if we
   ;; have 256 colors to display on a dark background.
   `(vertical-border ((,items-dark-console-256 (:background nil))))
   ;;`(font-lock-comment-face ((,items-dark-console-256 (:foreground "yellow"))))
   ;;`(font-lock-comment-delimiter-face
   )

  )


(when window-system


(defvar user-monitor-colors 'color
  "Decides whether the config is to be set for a color monitor or not")




;; FIXME: move all the font stuff to non-console initialization


;; Eval this to bring Emacs back to a small enough size with a small font so you
;; can see the minibuffer.
;; (user-font-set "-apple-courier-medium-r-normal--10-0-72-72-m-0-iso10646-1")

;; (defmacro switch (pred conditions)
;;   `(let ((fun ,pred))
;;      (cond ,(mapcar (lambda (x) (cons `(funcall fun ,(car x)) '(cdr x))) conditions))))

;; (user-font-set (get-user-font-default))

(defun get-user-font-default ()
  (if (eq window-system 'mac)
      "-apple-monaco-medium-r-normal--10-*-*-*-*-*-*-*"
    "Inconsolata-11"))
;; (set-default-font (get-user-font-default) t)

(defvar user-font-default (get-user-font-default)
  "Font for default frames.")


;; "-*-Lucida Console-bold-11-*"
;; "-*-fixed-bold-r-*-*-14-*-*-*"
;; "-*-fixed-bold-r-*-*-16-*-*-*"
;; "-*-fixedsys-*-*-*-*-*-*-*-*"
;; "-*-fixedsys-*-*-*-*-*-*-*-*" (Windows)
;; "-*-lucida console-bold-r-*-*-12-*-*-*"
;; "-*-lucida console-bold-r-*-*-15-*-*-*"
;; "-*-lucida console-bold-r-*-*-15-*-*-*"
;; "-b&h-lucidatypewriter-%s-r-normal-sans-*-%s-*-*-*-*-*-1"
;; "-b&h-lucidatypewriter-bold-r-normal-sans-*-100-*-*-*-*-*-1"
;; "-b&h-lucidatypewriter-bold-r-normal-sans-*-110-*-*-*-*-*-1"
;; "-b&h-lucidatypewriter-bold-r-normal-sans-*-140-*-*-*-*-*-1"
;; "-bitstream-bitstream vera sans mono-medium-r-*-*-10-*-*-*-*-*-*"
;; "-bitstream-bitstream vera sans mono-medium-r-*-*-12-*-*-*-*-*-*"
;; "-bitstream-bitstream vera sans mono-medium-r-*-*-12-*-*-*-*-*-*"
;; "-bitstream-bitstream vera sans mono-medium-r-*-*-12-*-*-*-*-*-*")))
;; "-monotype-andale mono-*-*-*--*-*-*-*-*-*-iso8859-1"
;; "-unknown-DejaVu Sans Mono-normal-normal-normal-*-12-*-*-*-m-0-iso8859-"
;; "-unknown-DejaVu Sans Mono-normal-normal-normal-*-12-*-*-*-m-0-iso8859-"
;; "Andale Mono-12"
;; "Andale Mono-12"
;; "Andale Mono-14"
;; "Bitstream Vera Sans Mono"
;; "Bitstream Vera Sans Mono-10.5"
;; "Bitstream Vera Sans Mono-11"
;; "Bitstream Vera Sans Mono-11"
;; "Bitstream Vera Sans Mono-12"
;; "Bitstream Vera Sans Mono-12"
;; "Bitstream Vera Sans Mono-9"
;; "DejaVu Sans Mono"
;; "DejaVu Sans Mono-10"
;; "DejaVu Sans Mono-10:bold"
;; "DejaVu Sans Mono:pixelsize=11" ;; same as gnome-terminal [2009-05-07]
;; "DejaVu Sans Mono:pixelsize=14"
;; "Inconsolata-10.5"
;; "Inconsolata-11"
;; "Inconsolata-13"
;; "Liberation Mono-11:bold"
;; "Monaco-10"
;; "Monospace-8"


;; For Windows fonts:
;;
;; To select using the font dialog and get the font string:
;; (insert (prin1-to-string (w32-select-font))
;; (insert (prin1-to-string (x-list-fonts "*")))
;;
;; To see the entire list of fonts:
;; (insert (prin1-to-string (x-list-fonts "*")))
;; (with-output-to-temp-buffer (mapcar (lambda (x) (prin1 x)) (x-list-fonts "*Bitstream*")))
;;
;; Use this space to try a font out:
;; (user-font-set (get-user-font-default))
;; (dolist (x (frame-parameters)) (print x))

(defun user-asian-font-switch-all-faces ()
  "Command to switch all faces to an asian font.
Eventually we need to make our own font menu that works."
  (interactive)
  (user-font-set
  "-b&h-lucidatypewriter-bold-r-normal-sans-*-170-*-*-*-*-*-1"))

(defvar user-special-display-font
  "-b&h-lucidatypewriter-bold-r-normal-sans-*-100-*-*-*-*-*-1"
  "Font for special frames.")

(defvar user-minibuffer-font
  "-b&h-lucidatypewriter-bold-r-normal-sans-*-100-*-*-*-*-*-1"
  "Font for minibuffer frame.")

(defvar user-default-frame-width 83
  "Width for programming frame")

(defvar user-default-frame-height 61
  "Width for programming frame")



; FIXME: move this to the graphics section
;;------------------------------------------------------------------------------
;; Fringe and scroll-bars.

(defun small-screen-p ()
  "Return true if we're on a small screen."
  (assert (not (eq window-system nil)))
  (and (> (display-pixel-width) 1200)
       (> (display-pixel-height) 800)))

(when (and (not (eq window-system nil))
	   (small-screen-p))

  ;; Minimize the clutter on margins, especially on laptop
  (set-fringe-mode '(1 . 1))
  (set-fringe-style '(1 . 1))

  ;; Remove the scroll bars.
  (set-scroll-bar-mode nil)
  )






(cond

  ((memq window-system '(x w32 mac))

   ;; save x clipboard into kill-ring
   ;;(setq interprogram-cut-function nil)
   ;; interprogram-paste-function

   (defun push-x-selection-on-kill-ring ()
     (interactive)
     (kill-new (x-get-selection)))
   ;; (global-set-key* [(control x)(control k)] 'push-x-selection-on-kill-ring)

   ;;
   ;; je sais qu'y a moyen de le faire marcher, mais j'me souviens plus comment.
   ;; et le code do current-kill ne m'a donn de rponse satisfaisante.
   ;; il semble que le code qui le faisait a t limin.
   ;; mais peut-tre qu'on peut faire mieux: quand tu fais c-k, tu peux
   ;; vrifier s'il y a une slection extrieure et si oui, tu la push sur le
   ;; kill-ring avant de pusher le texte du c-k.
   ;;


   ;;---------------------------------------------------------------------------
   ;; fonts and faces

   ;; font menu
  ;;; (setq
  ;;;  x-fixed-font-alist
  ;;;  '("font menu"
  ;;;    ("misc"
  ;;;     ("sgi to linux"
  ;;;      "-b&h-lucidatypewriter-bold-r-normal-sans-*-140-*-*-*-*-*-1")
  ;;;     ("")
  ;;;     ("6x12" "-misc-fixed-medium-r-semicondensed--12-110-75-75-c-60-*-1")
  ;;;     ("6x13" "-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-*-1")
  ;;;     ("lucida 13"
  ;;;        "-b&h-lucidatypewriter-medium-r-normal-sans-0-0-0-0-m-0-*-1")
  ;;;     ("lucida bigger"
  ;;;      "-b&h-lucidatypewriter-bold-r-normal-sans-0-140-*-*-m-0-*-1")
  ;;;     ("7x13" "-misc-fixed-medium-r-normal--13-120-75-75-c-70-*-1")
  ;;;     ("7x14" "-misc-fixed-medium-r-normal--14-130-75-75-c-70-*-1")
  ;;;     ("9x15" "-misc-fixed-medium-r-normal--15-140-*-*-c-*-*-1")
  ;;;     ("")
  ;;;     ("clean 8x8" "-schumacher-clean-medium-r-normal--*-80-*-*-c-*-*-1")
  ;;;     ("clean 8x14" "-schumacher-clean-medium-r-normal--*-140-*-*-c-*-*-1")
  ;;;     ("clean 8x10" "-schumacher-clean-medium-r-normal--*-100-*-*-c-*-*-1")
  ;;;     ("clean 8x16" "-schumacher-clean-medium-r-normal--*-160-*-*-c-*-*-1")
  ;;;     ("")
  ;;;     ("sony 8x16" "-sony-fixed-medium-r-normal--16-120-100-100-c-80-*-1")
  ;;;     ("")
  ;;;     ("-- courier --")
  ;;;     ("courier 10" "-adobe-courier-medium-r-normal--*-100-*-*-m-*-*-1")
  ;;;     ("courier 12" "-adobe-courier-medium-r-normal--*-120-*-*-m-*-*-1")
  ;;;     ("courier 14" "-adobe-courier-medium-r-normal--*-140-*-*-m-*-*-1")
  ;;;     ("courier 18" "-adobe-courier-medium-r-normal--*-180-*-*-m-*-*-1")
  ;;;     ("courier 18-b" "-adobe-courier-bold-r-normal--*-180-*-*-m-*-*-1")
  ;;;     )))


   ;; basic faces in emacs-21: (list-faces-display)
   ;; ('default
   ;;   'mode-line
   ;;   'header-line
   ;;   'tool-bar
   ;;   'region
   ;;   'fringe
   ;;   'scroll-bar
   ;;   'menu
   ;;   'border
   ;;   'cursor
   ;;   'mouse
   ;;   'bold
   ;;   'italic
   ;;   'bold-italic
   ;;   'underline
   ;;   'highlight
   ;;   'secondary-selection
   ;;   'fixed-pitch
   ;;   'variable-pitch
   ;;   'trailing-whitespace)
   (set-face-background 'trailing-whitespace "gray85")

   ;;---------------------------------------------------------------------------
   ;; changing font-size while running.
   ;; (we could put the following snippet in a separate file.)

   (if t
       (progn
	 (global-set-key* [(control c)(control -)] 'text-scale-adjust)
	 (setq text-scale-mode-step 1.05)
	 )

     (progn
       ;; Note: this has been superseded by text-scale-adjust.
       ;; You can delete this some time after [2011-07-11] if it works well.

       (defun user-font-set (fontsp)
	 "change font for most standard faces."
	 (set-default-font fontsp)
	 (mapcar
	  (lambda (x) (set-face-font x fontsp))
	  (list 'default 'highlight 'region 'secondary-selection
		'bold 'italic 'bold-italic 'underline
		'buffer-menu-buffer 'comint-highlight-input
		'modeline 'mode-line-buffer-id 'mode-line-inactive
		'compilation-error 'compilation-warning 'compilation-info
		'font-lock-warning-face)) )

       (when (and user-font-default (not (eq window-system 'w32)))
	 (user-font-set user-font-default) )

       (defun user-mouse-set-font ()
	 (interactive)
	 (call-interactively 'mouse-set-font)
	 )


       (defun user-font-change (fun)
	 "Change the current font size."
	 (let* (;; Save the frame heights to automatically resize them.
		(frame-heights
		 (mapcar
		  (lambda (x) (cons x (* (frame-height x) (frame-char-height x))))
		  (frame-list)))
		(sz (face-attribute 'default :height))
		(orig-char-height (frame-char-height)))
	   (while (= (frame-char-height) orig-char-height)
	     (setq sz (funcall fun sz))
	     (message "Font size: %s" sz)

	     ;; note: the commands here could be arbitrary, i.e. different scaling
	     ;; for different frames, and the frame resizing should still work.
	     (dolist (face (face-list))
	       (set-face-attribute face nil :height sz))
	     )

	   (let (f h new-h)
	     (dolist (x frame-heights)
	       (setq frame (car x)
		     pxh (cdr x))
	       (setq new-h (truncate (/ pxh (frame-char-height frame))))
	       (set-frame-height frame new-h)
	       ))))

       (defun user-font-enlarge ()
	 "enlarge or reduce the current font (depending on the
        current prefix argument)."
	 (interactive)
	 (user-font-change (if current-prefix-arg #'1- #'1+)))

       (repeatable-command-advice user-font-enlarge)
       (global-set-key* [(control c)(control -)] 'user-font-enlarge)

       ))


     ;;)

   ) ;; window-system





;;;; ==========================================================================
;;;; *
;;;; *  Color and font-lock
;;;; *
;;;; ==========================================================================

   (cond
    ;;-------------------------------------------------------------------------
    ;; B&W monitor
    ((equal user-monitor-colors 'gray)

     (set-face-background 'highlight "gray70")
     (set-face-background 'region "black")
     (set-face-foreground 'region "white")

     ;; (set-face-background 'region "#A0E0F8")


     ;; (face foreground background bold-p italic-p underline-p)
     (setq font-lock-face-attributes
           '((font-lock-comment-face "grey30" nil nil t nil)
             (font-lock-string-face "grey10" nil nil t nil)
             (font-lock-keyword-face nil nil nil nil nil)
             (font-lock-function-name-face "grey30" nil t nil nil)
             (font-lock-variable-name-face il nil t nil nil)
             (font-lock-type-face nil nil nil nil nil)
             (font-lock-reference-face nil nil nil nil nil)
             (makefile-tab-face nil "grey85" nil nil nil)))

     )

    ;;-------------------------------------------------------------------------
    ;; Color monitor, running with graphics with own window

    ((and (equal user-monitor-colors 'color) window-system)

     (set-face-background 'highlight "gray70") ; SteelBlue
     (set-face-background 'region "#BFDFEF") ;; "#D6E6EA") ;; "#DFF0EF") ;; "#BFDFEF") ;; SkyBlue
     (set-face-background 'fringe "gray85")

     (set-face-background 'secondary-selection "#E8E8E8") ;; "SlateGray"

     (custom-set-faces
      '(font-lock-comment-face ((((class color) (background light))
                                 (:foreground "grey45"))))
      '(font-lock-string-face ((((class color) (background light))
				(:foreground "#FF5588")))))

     )

    ;;-------------------------------------------------------------------------
    ;; Color monitor, running in console

    ((and (equal user-monitor-colors 'color) (not window-system))


     )
    )



   ;;---------------------------------------------------------------------------
   ;; font-lock

;; (defvar user-use-font-lock t ;; (not (string-match "estonia" system-name))
;;   "Determines whether we use font-lock for this config")
   (if t ;; (equal user-use-font-lock 't)
       (progn
         (require 'font-lock)
         (global-font-lock-mode t)




;; Stefan:
;; Pour moi, fast-lock n'a jamais rien t de plus qu'une exprience qui
;; a montr que c'tait pas une bonne ide.  lazy-lock tait pas mal, et
;; jit-lock est une rimplantation de lazy-lock qui profite d'un nouveau
;; hook ajout exprs pour.

;; (defvar user-fast-lock-cache-dir (concat home "/.emacs-flc")
;;   "Directory for fast lock cache files.")

         ;; (cond ((equal user-font-lock-support-mode 'fast)
         ;;        (require 'fast-lock)
         ;;        (setq font-lock-support-mode 'fast-lock-mode)
         ;;        (setq fast-lock-cache-directories
         ;;              (list user-fast-lock-cache-dir)))

         ;;       ((equal user-font-lock-support-mode 'lazy)
         ;;        (require 'lazy-lock)
         ;;        (setq lazy-lock-minimum-size 1000)
         ;;        (setq font-lock-support-mode 'lazy-lock-mode) )

         ;;       ((equal user-font-lock-support-mode 'jit)
         ;;        (require 'jit-lock)
         ;;        (setq font-lock-support-mode 'jit-lock-mode)))




         ;;(setq font-lock-modes
         ;;      '(lisp-interaction emacs-lisp  c c++ perl winmgr makefile))
         ;;(dolist (mode font-lock-modes)
         ;;  (let ((hook (intern (concat (symbol-name mode) "-mode-hook"))))
         ;;    (add-hook hook turn-on-font-lock t)))

         ;;(setq font-lock-verbose t)
         (setq font-lock-maximum-size (* font-lock-maximum-size 2))

         (setq font-lock-maximum-decoration t)
         ;;(setq lazy-lock-continuity-time 0.3)
         ;;(setq lazy-lock-stealth-lines 500)
         ;;(setq lazy-lock-stealth-time 10)

         ;;(setq font-lock-defaults-alist
         ;;      (append '((fi:common-lisp-mode
         ;;              lisp-font-lock-keywords
         ;;              nil t ((58 . "w") (45 . "w") (42 . "w")))
         ;;             (lisp-interaction-mode
         ;;              lisp-font-lock-keywords
         ;;              nil t ((58 . "w") (45 . "w") (42 . "w"))))
         ;;           font-lock-defaults-alist))

         ;; --------------------------------------------------------------------
         ;; Additional types for highlighting

         (custom-set-variables
          '(c++-font-lock-extra-types
            ;; '(c++-font-lock-keywords-2
            (append '( "string"
                       "wchar_t"
                       "\\<gl[A-Z][a-zA-Z0-9]+\\>"
                       "\\<GL_[A-Z0-9_]+\\>"
                       ;; '("\\<(?Q[A-Z][a-zA-Z0-9]+\\>"
                       )
                    c++-font-lock-extra-types)
            ))

         ))

   ;;---------------------------------------------------------------------------
   ;; frame titles

   ;;(setq frame-title-format '("%b"))
   ;;(setq icon-title-format '("%1+%b"))


   ;;---------------------------------------------------------------------------
   ;; frame properties

   (setq default-frame-alist
	 `(
	   (width . ,user-default-frame-width)
	   (height . ,user-default-frame-height)
	   (background-color . "white")
	   ;;(background-color . "gray90")
	   (cursor-color . "red")
	   ))

   ;;(if (eq system-type 'windows-nt)
   ;;    (setcdr (assoc 'height default-frame-alist) 74))

   (setq special-display-frame-alist
	 `(
	   (width . 132) (height . 30)
	   (left . -120) (top . -22)
	   ,@(unless (eq window-system 'mac)
	       (list (cons 'font user-special-display-font)))
	   (foreground-color . "black")
	   (background-color . "gray90")
	   (cursor-color . "black")
	   ))

   (setq minibuffer-frame-alist nil)



;;------------------------------------------------------------------------------
;; Drag and drop

   (defun dnd-open-local-file-and-location (uri action)
     "Open a local file and go to a specified file number.

This function effectively supports an originally created protocol
to indicate errors, to be able to dnd them into Emacs.  For example::

  fileloc:///path-to-something/lib/python/ranvier/mapper.py:401

Indicates that we should go to line 401 of the given file.
"
     (when (string-match "\\(fileloc\\|edit\\)://\\(.*\\):\\([0-9]+\\)$" uri)
       (let ((filename (match-string 2 uri))
             (line (match-string 3 uri)))
         (dnd-open-local-file (concat "file://" filename) action)
         (goto-line (string-to-int line))
         )))

   (add-to-list 'dnd-protocol-alist
                (cons "fileloc:///" 'dnd-open-local-file-and-location))

   ))
;;; end of window-system conditionals






;;;; ==========================================================================
;;;; *
;;;; *  Project and site specific initialization
;;;; *
;;;; ==========================================================================

(defun project-load-emacs-files (root relfn &optional pred)
  "Loads all the 'ROOT/*/RELFN' filenames under all the directories under ROOT
whose basenames match the PRED predicate."
  (let ((predfun (or pred (lambda (x) t))))
    (dolist (dn (filter predfun (directory-files root)))
      (let* ((project-current (concat root "/" dn))
	     (project-current-load-file (concat project-current "/" relfn)))
	(when (file-exists-p project-current-load-file)
	  (load-file project-current-load-file))))))

(when (and user-projects-root (file-exists-p user-projects-root))

  ;; Load all the conf files first.
  (project-load-emacs-files user-projects-root "etc/emacsrc"
			    (lambda (x) (string-match "conf-" x)))


  ;; Load all the other project files in a second step.
  (project-load-emacs-files user-projects-root "etc/emacsrc"
			    (lambda (x) (and (string-match "[a-z0-9]+" x)
					     (not (string-match "conf" x)))))
)

;; Automatically initialize the filecache on startup.
;; We do this after processing the project files, which may add to the filecache.
(file-cache-initialize)




;;;; ==========================================================================
;;;; *
;;;; *  Fluff
;;;; *
;;;; ==========================================================================

;; new packages to try out:

;; highlight-regexp

;; re-builder

;; *** whitespace.el is a package for warning about and cleaning bogus
;; whitespace in a file.

;; delim-col, interesting to clean up some code

;; *** elide-head.el provides a mechanism for eliding boilerplate header text.

;; ** The new global minor mode `auto-image-file-mode' allows image files
;; to be visited as images.

;; dolist and dotimes functions




(defun get-next-filename ()
  "Returns the next available filename with a numeric suffix,
e.g. filename.2"
  (let ((base (buffer-file-name))
        (i 1))
    (while (let ((fn (concat base (format ".%s" i))))
             (file-exists-p fn))
      (setq i (1+ i)))
    (concat base (format ".%s" i))))

(defun write-snapshot ()
  "Write a snapshot of the current buffer into a file with
an increasing numeric suffix."
  (interactive)
  (let ((fn (get-next-filename)))
    (write-region (point-min) (point-max) fn)))

(defadvice write-file (around write-snapshot activate)
  (if current-prefix-arg
      (write-snapshot)
    ad-do-it))




(defun align-pairs (beg end)
  "Align pairs of attributes."
  (interactive "r")
  (align-regexp beg end "^\\s-+\\S-+\\(\\s-+\\)\\S-+\\s-*[=;]" 1 2 nil) )


;; END
;;------------------------------------------------------------------------------

;; Do this for comment-region:
;; Un minor-mode binding fait justement a.  Si tu le mets  la fin de
;; minor-mode-map-alist, il ne couvrira pas les autres minor-modes.
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(ediff-current-diff-A ((((class color)) (:background "#abab33" :weight bold))))
 '(ediff-current-diff-B ((((class color)) (:background "#abab33" :weight bold))))
 '(ediff-current-diff-C ((((class color)) (:background "#abab33" :weight bold))))
 '(ediff-even-diff-A ((((class color)) (:background "#666" :weight bold))))
 '(ediff-even-diff-B ((((class color)) (:background "#666" :weight bold))))
 '(ediff-even-diff-C ((((class color)) (:background "#666" :weight bold))))
 '(ediff-fine-diff-A ((((class color)) (:background "#cdcd33" :weight bold))))
 '(ediff-fine-diff-B ((((class color)) (:background "#cdcd33" :weight bold))))
 '(ediff-fine-diff-C ((((class color)) (:background "#cdcd33" :weight bold))))
 '(ediff-odd-diff-A ((((class color)) (:background "#666" :weight bold))))
 '(ediff-odd-diff-B ((((class color)) (:background "#666" :weight bold))))
 '(ediff-odd-diff-C ((((class color)) (:background "#666" :weight bold))))
 '(vertical-border ((((class color) (min-colors 256) (background dark)) (:background nil)))))




;; Useful to evaluate math expressions in buffers.
(defun calc-eval-region (arg beg end)
  "Calculate the region and display the result in the echo area.
With prefix ARG non-nil, insert the result at the end of region."
  (interactive "P\nr")
  (let* ((expr (buffer-substring-no-properties beg end))
         (result (calc-eval expr)))
    (if (null arg)
        (message "%s = %s" expr result)
      (goto-char end)
      (save-excursion
        (insert result)))))


(when nil
  (require 'package)
  (add-to-list 'package-archives
               '("marmalade" .
                 "http://marmalade-repo.org/packages/"))
  (package-initialize)
  )


;;; Try this at some point:
;;;
;;; On that topic, I find the following configuration in my ~/emacs.d/init.el useful to make sure my Emacs shell buffer doesn't get too large, has a read-only prompt, and can still be deleted when I choose:
;;;
;;; ;; Shell Settings
;;; ; Make the prompt read-only, but let C-w still delete it.
;;; (set 'comint-prompt-read-only t)
;;; (add-hook 'comint-mode-hook
;;;           (lambda ()
;;;             (define-key comint-mode-map "\C-w" 'comint-kill-region)
;;;             (define-key comint-mode-map [C-S-backspace]
;;;               'comint-kill-whole-line)))
;;; ; Enable colour.
;;; (add-hook 'comint-mode-hook 'ansi-color-for-comint-mode-on)
;;; ; Limit the max buffer size.
;;; (setq comint-buffer-maximum-size 1024)
;;; (add-hook 'comint-output-filter-functions
;;;           'comint-truncate-buffer)
